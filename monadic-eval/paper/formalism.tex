\newcommand{\lamif}{Â«Î»â¦‘IFâ¦’Â» }

\section{Formalism}

In this section we formalize our approach to designing static analyzers via
definitional interpreters. The development begins with a ``ground truth''
big-step semantics and concludes with the fixpoint iteration strategy described
in Section~\ref{TODO}, which we prove sound w.r.t. a synthesized abstract
semantics. The design is systematic, and applies to arbitrary programming
languages described via big-step operational semantics. We demonstrate the
systematic process as applied to a subset of the language described in
Figure~\ref{TODO}, which we call \lamif.

\paragraph{Concrete Semantics}

We begin with the concrete semantics of \lamif as a big-step relation
Â«Ï,Ï„âŠ¢e,Ïƒâ‡“v,Ïƒâ€²Â», shown in Figures~\ref{TODO} and~\ref{TODO}. The definition is
mostly standard: Â«ÏÂ» and Â«ÏƒÂ» are the environment and store, Â«eÂ» is the initial
expression, and Â«vÂ» is the resulting value. The argument Â«Ï„Â» represents
``time'', which when abstracted supports modeling execution contexts like
call-site sensitivity. Concretely time is modelled as a natural number and
represents the number of steps of execution.

\begin{figure} %{-{
\begin{alignat*}{3}
  n âˆˆ &&\mathrel{} lits \mathrel{\hphantom{â‰”}} & \\
  x âˆˆ &&\mathrel{} vars \mathrel{\hphantom{â‰”}} & \\
  b âˆˆ &&\mathrel{}  binop â‰” &\mathrel{} â´âŸ¬plusâŸ­, â€¦âµ \\
  e âˆˆ &&\mathrel{}    exp â©´ &\mathrel{} n âˆ£ x âˆ£ Î»x.e âˆ£ e(e) âˆ£ âŸ¬if0âŸ­(e)â´eâµâ´eâµ âˆ£ b(e,e) \\
  Ï âˆˆ &&\mathrel{}    env â‰” &\mathrel{} var â†’ addrâ¸¤âŠ¥â¸¥ \\
  Ïƒ âˆˆ &&\mathrel{}  store â‰” &\mathrel{} addr â†’ valâ¸¤âŠ¥â¸¥ \\
  v âˆˆ &&\mathrel{}    val â©´ &\mathrel{} n âˆ£ âŸ¨Î»x.e,ÏâŸ© \\
  â„“ âˆˆ &&\mathrel{}   addr â‰” &\mathrel{} var Ã— time \\
  Ï„ âˆˆ &&\mathrel{}   time â‰” &\mathrel{} â„•
\end{alignat*}
\caption{\lamif{} Syntactic Categories}
\end{figure} %}-}

\begin{figure} %{-{
\begin{mathpar}

  \inferrule*[left=(Lit)]{ }{Ï , Ï„ âŠ¢ n , Ïƒ â‡“ n , Ïƒ}

  \inferrule*[left=(Var)]{ }{Ï , Ï„ âŠ¢ x , Ïƒ â‡“ Ïƒ(Ï(x)) , Ïƒ}

  \inferrule*[left=(Lam)]{ }{Ï , Ï„ âŠ¢ Î»x.e , Ïƒ â‡“ âŸ¨Î»x.e,ÏâŸ© , Ïƒ}

  \inferrule*[left=(App),right={\begin{minipage}{2em}\ssmall
    \begin{alignat*}{1}
    \begin{alignedat}{2} 
âŸ¨Î»x.eâ€²,Ïâ€²âŸ© = &\mathrel{} vâ‚ \\[-0.5em]
        Ï„â€² = &\mathrel{} Ï„+1 \\[-0.5em]
        â„“  = &\mathrel{} âŸ¨x,Ï„â€²âŸ© \\
      \end{alignedat}
    \end{alignat*}
  \end{minipage}}]{
  Ï       , Ï„  âŠ¢ eâ‚    , Ïƒ        â‡“ vâ‚ , Ïƒâ‚ \\
  Ï       , Ï„  âŠ¢ eâ‚‚    , Ïƒâ‚       â‡“ vâ‚‚ , Ïƒâ‚‚ \\
  Ïâ€²[xâ†¦â„“] , Ï„â€² âŠ¢ eâ€²    , Ïƒâ‚‚[â„“â†¦vâ‚‚] â‡“ vâ€² , Ïƒâ‚ƒ}
  {Ï      , Ï„ âŠ¢ eâ‚(eâ‚‚) , Ïƒ        â‡“ vâ€² , Ïƒâ‚ƒ}

  \inferrule*[left=(If-T),right={\ssmall Â«n=0Â»}]{
  Ï , Ï„ âŠ¢ eâ‚ , Ïƒ â‡“ n , Ïƒâ‚ \\
  Ï , Ï„ âŠ¢ eâ‚‚ , Ïƒâ‚ â‡“ v , Ïƒâ‚‚}
  {Ï , Ï„ âŠ¢ âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ , Ïƒ â‡“ v , Ïƒâ‚‚}

  \inferrule*[left=(If-F),right={\ssmall Â«nâ‰ 0Â»}]{
    Ï , Ï„ âŠ¢ eâ‚ , Ïƒ  â‡“ n , Ïƒâ‚ \\
    Ï , Ï„ âŠ¢ eâ‚ƒ , Ïƒâ‚ â‡“ v , Ïƒâ‚‚}
  {Ï , Ï„ âŠ¢ âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ , Ïƒ â‡“ v , Ïƒâ‚‚}

  \inferrule*[left=(Bin)]{
  Ï , Ï„ âŠ¢ eâ‚ , Ïƒ  â‡“ vâ‚ , Ïƒâ‚ \\
  Ï , Ï„ âŠ¢ eâ‚‚ , Ïƒâ‚ â‡“ vâ‚‚ , Ïƒâ‚‚}
  {Ï , Ï„ âŠ¢ b(eâ‚,eâ‚‚) , Ïƒ â‡“ âŸ¦bâŸ§(vâ‚,vâ‚‚) , Ïƒâ‚‚}
\end{mathpar}
\caption{\lamif{} Big-step Concrete Semantics}
\end{figure} %}-}

\paragraph{Reachability}

The primary limitation of using big-step semantics as a starting point for
abstraction is that intermediate computations are not represented in the model.
For example, consider the program that applies the identity function to an
expression that loops, which we notate Â«Î©Â»:
\[ (Î»x.x)(Î©) \]
A big-step semantics can only describe results of terminating computations, and
because this program never terminates, our big-step semantics relation says
nothing about the behavior of the program. A good static analyzer will explore
the behavior of Â«Î©Â» to (possibly) discover that it loops, but more importantly,
to provide analysis results (like data-flow or side-effects) for intermediate
computation states.

The need to analyze intermediate states is the primary reason that big-step
semantics are overlooked as a starting point for abstract interpretation. To
remedy the situation, while remaining in a big-step setting, we introduce a
big-step \emph{reachability semantics}, described by the relation Â«Ï,Ï„âŠ¢e,Ïƒâ‡‘Ï‚Â»
shown in Figure~\ref{TODO}. Configurations Â«Ï‚Â» are tuples Â«âŸ¨e,Ï,Ïƒ,Ï„âŸ©Â», and are
reachable when evaluation passes through the configuration at any point on its
way to a final value, or during an infinite loop.

\begin{figure} %{-{
\begin{mathpar}
  \inferrule*[left=(Refl)]{ }{Ï,Ï„âŠ¢e,Ïƒâ‡‘âŸ¨e,Ï,Ïƒ,Ï„âŸ©}

  \inferrule*[left=(RApp1)]
   {Ï,Ï„âŠ¢eâ‚,Ïƒâ‡‘Ï‚}
   {Ï,Ï„âŠ¢eâ‚(eâ‚‚),Ïƒâ‡‘Ï‚}

   \inferrule*[left=(RApp2),right={\ssmall Â«âŸ¨Î»x.eâ€²,Ïâ€²âŸ©=vâ‚Â»}]
   {  Ï,Ï„âŠ¢eâ‚,Ïƒâ‡“vâ‚,Ïƒâ‚
   \\ Ï,Ï„âŠ¢eâ‚‚,Ïƒâ‚â‡‘Ï‚}
   {Ï,Ï„âŠ¢eâ‚(eâ‚‚),Ïƒâ‡‘Ï‚}

   \inferrule*[left=(RApp3),right={\begin{minipage}{2em}\ssmall
       \begin{alignat*}{1}
       \begin{alignedat}{2} 
    âŸ¨Î»x.eâ€²,Ïâ€²âŸ© = &\mathrel{} vâ‚ \\[-0.5em]
           Ï„â€² = &\mathrel{} Ï„+1 \\[-0.5em]
           â„“  = &\mathrel{} âŸ¨x,Ï„â€²âŸ© \\
         \end{alignedat}
       \end{alignat*}
     \end{minipage}}]
  {  Ï,Ï„âŠ¢eâ‚,Ïƒ â‡“vâ‚,Ïƒâ‚
  \\ Ï,Ï„âŠ¢eâ‚‚,Ïƒâ‚â‡“vâ‚‚,Ïƒâ‚‚
  \\ Ïâ€²[xâ†¦â„“],Ï„â€²âŠ¢eâ€²,Ïƒâ‚‚[â„“â†¦vâ‚‚]â‡‘Ï‚}
  {Ï,Ï„âŠ¢eâ‚(eâ‚‚),Ïƒâ‡‘Ï‚}

  \inferrule*[left=(RIf1)]
  {Ï,Ï„âŠ¢eâ‚,Ïƒâ‡‘Ï‚}
  {Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,Ïƒâ‡‘Ï‚}

  \inferrule*[left=(RIf-T),right={\ssmall Â«n=0Â»}]
  {  Ï,Ï„âŠ¢eâ‚,Ïƒâ‡“n,Ïƒâ‚
  \\ Ï,Ï„âŠ¢eâ‚‚,Ïƒâ‚â‡‘Ï‚}
  {Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,Ïƒâ‡‘Ï‚}

  \inferrule*[left=(RIf-F),right={\ssmall Â«nâ‰ 0Â»}]
  {  Ï,Ï„âŠ¢eâ‚,Ïƒâ‡“n,Ïƒâ‚
  \\ Ï,Ï„âŠ¢eâ‚ƒ,Ïƒâ‚â‡‘Ï‚}
  {Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,Ïƒâ‡‘Ï‚}

  \inferrule*[left=(RBin1)]
  {Ï,Ï„âŠ¢eâ‚,Ïƒâ‡‘Ï‚}
  {Ï,Ï„âŠ¢b(eâ‚,eâ‚‚),Ïƒâ‡‘Ï‚}

  \inferrule*[left=(RBin2)]
  {  Ï,Ï„âŠ¢eâ‚,Ïƒâ‡“vâ‚,Ïƒâ‚
  \\ Ï,Ï„âŠ¢eâ‚‚,Ïƒâ‚â‡‘Ï‚}
  {Ï,Ï„âŠ¢b(eâ‚,eâ‚‚),Ïƒâ‡‘Ï‚}

\end{mathpar}
\caption{\lamif{} Big-step Reachability Semantics}
\end{figure} %}-}

The complete concrete semantics of an expression (Â«eÂ») under environment (Â«ÏÂ»),
store (Â«ÏƒÂ») and time (Â«Ï„Â»), which we notate Â«âŸ¦eâŸ§â¸¢bsâ¸£(Ï,Ïƒ,Ï„)Â», is then a pairing
of the set of resulting values and final stores (Â«v,Ïƒâ€²Â»), and the reachable
configurations (Â«Ï‚Â»):
\begin{alignat*}{1}
  & âŸ¦eâŸ§â¸¢bsâ¸£(Ï,Ïƒ,Ï„) â‰” \\
  & \hspace{1em}âŸ¨â´âŸ¨v,Ïƒâ€²âŸ© âˆ£ Ï,Ï„âŠ¢e,Ïƒâ‡“v,Ïƒâ€²âµ,â´Ï‚ âˆ£ Ï,Ï„âŠ¢e,Ïƒâ‡‘Ï‚âµâŸ©
\end{alignat*}
We then construct a formal bridge between the complete concrete semantics
(Â«âŸ¦eâŸ§â¸¢bsâ¸£Â») and a complete small step semantics, which is traditionally used as
the starting point of abstraction for program analysis:
\begin{alignat*}{1}
  & âŸ¦eâŸ§â¸¢ssâ¸£(Ï,Ïƒ,Ï„) â‰” \\
  & \hspace{1em}âŸ¨â´âŸ¨v,Ïƒâ€²âŸ© âˆ£ âˆ€Îº. âŸ¨e,Ï,Ïƒ,Ï„,ÎºâŸ© â†â¸¢*â¸£ âŸ¨v,Ïâ€²,Ïƒâ€²,Ï„â€²,ÎºâŸ©âµ \\
  & \hspace{1em},â´âŸ¨eâ€²,Ïâ€²,Ïƒâ€²,Ï„â€²âŸ© âˆ£ âˆ€Îº. âŸ¨e,Ï,Ïƒ,Ï„,ÎºâŸ© â†â¸¢*â¸£ âŸ¨eâ€²,Ïâ€²,Ïƒâ€²,Ï„â€²,Îºâ€²â§ºÎºâŸ©âµâŸ©
\end{alignat*}
We connect the complete big-step and small-step semantics through the following
theorem:
\begin{theorem}[Complete Big-step/Small-step Equivalence]
  Forall Â«eÂ», Â«ÏÂ», Â«ÏƒÂ» and Â«Ï„Â», the complete big-step and
  complete small-step semantics are equivalent, that is:
  \[ âŸ¦eâŸ§â¸¢bsâ¸£(Ï,Ïƒ,Ï„) = âŸ¦eâŸ§â¸¢ssâ¸£(Ï,Ïƒ,Ï„) \]
\end{theorem}
The proof is a straightforward induction on the big-step derivation in the Â«âŠ†Â»
direction, and on the transitive small-step derivation in the Â«âŠ‡Â» direction.

\paragraph{Collecting Semantics}

Before abstracting the semanticsâ€”in pursuit of a sound static analysis
algorithmâ€”we pass through a big-step collecting and reachability semantics,
Â«Ï,Ï„âŠ¢e,âˆ¿{Ïƒ}â‡“âˆ¿{v},âˆ¿{Ïƒ}Â» and Â«Ï,Ï„âŠ¢e,âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}Â», shown in Figure~\ref{TODO}, where
Â«âˆ¿{v}Â», Â«âˆ¿{Ïƒ}Â» and Â«âˆ¿{Ï‚}Â» range over collecting state spaces:
\begin{alignat*}{3}
    âˆ¿{v} âˆˆ &&\mathrel{} âˆ¿{val}      &\mathrel{} â‰” â„˜(val) \\
    âˆ¿{Ïƒ} âˆˆ &&\mathrel{} âˆ¿{store}    &\mathrel{} â‰” addr â†¦ âˆ¿{val} \\
    âˆ¿{Ï‚} âˆˆ &&\mathrel{} âˆ¿{config}   &\mathrel{} â‰” exp Ã— env Ã— âˆ¿{store} Ã— time
\end{alignat*}
The denotation for binary operators (Â«âŸ¦bâŸ§Â») is lifted to a collecting
denotation operator Â«âˆ¿{âŸ¦bâŸ§}Â»:
\[ âˆ¿{âŸ¦bâŸ§}(âˆ¿{v}â‚,âˆ¿{v}â‚‚) â‰” â´âŸ¦bâŸ§(vâ‚,vâ‚‚) âˆ£ vâ‚ âˆˆ âˆ¿{v}â‚ âˆ§ vâ‚‚ âˆˆ âˆ¿{v}â‚‚âµ \]

\begin{figure} %{-{
\begin{mathpar}
  \inferrule*[left=(OLit)]{ }{Ï,Ï„âŠ¢n,âˆ¿{Ïƒ}â‡“â´nâµ,âˆ¿{Ïƒ}}

  \inferrule*[left=(OVar)]{ }{Ï,Ï„âŠ¢x,âˆ¿{Ïƒ}â‡“âˆ¿{Ïƒ}(Ï(x)),âˆ¿{Ïƒ}}

  \inferrule*[left=(OLam)]{ }{Ï,Ï„âŠ¢Î»x.e,âˆ¿{Ïƒ}â‡“â´âŸ¨Î»x.e,ÏâŸ©âµ,âˆ¿{Ïƒ}}

  \inferrule*[left=(OApp),right={\begin{minipage}{2em}\ssmall
    \begin{alignat*}{1}
    \begin{alignedat}{2} 
              âŸ¨Î»x.eâ€²,Ïâ€²âŸ© âˆˆ &\mathrel{} âˆ¿{v}â‚ \\[-0.5em]
                      Ï„â€² = &\mathrel{} Ï„+1 \\[-0.5em]
                      â„“  = &\mathrel{} âŸ¨x,Ï„â€²âŸ©
      \end{alignedat}
    \end{alignat*}
  \end{minipage}}]
  {  Ï      ,Ï„ âŠ¢eâ‚    ,âˆ¿{Ïƒ} â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
  \\ Ï      ,Ï„ âŠ¢eâ‚‚    ,âˆ¿{Ïƒ}â‚â‡“âˆ¿{v}â‚‚,âˆ¿{Ïƒ}â‚‚
  \\ Ïâ€²[xâ†¦â„“],Ï„â€²âŠ¢eâ€²    ,âˆ¿{Ïƒ}â‚‚âŠ”[â„“â†¦âˆ¿{v}â‚‚]â‡“âˆ¿{v}â€²,âˆ¿{Ïƒ}â‚ƒ}
  {Ï      ,Ï„ âŠ¢eâ‚(eâ‚‚),âˆ¿{Ïƒ} â‡“âˆ¿{v}â€²,âˆ¿{Ïƒ}â‚ƒ}

  \inferrule*[left=(OIf-T),right={\ssmall Â«0âˆˆâˆ¿{v}â‚Â»}]
  {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
  \\ Ï,Ï„âŠ¢eâ‚‚,âˆ¿{Ïƒ}â‚â‡“âˆ¿{v},âˆ¿{Ïƒ}â‚‚}
  {  Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,âˆ¿{Ïƒ}â‡“âˆ¿{v},âˆ¿{Ïƒ}â‚‚}

  \inferrule*[left=(OIf-F),right={\begin{minipage}{2em}\ssmall
      \begin{alignat*}{2}
        n âˆˆ &\mathrel{} âˆ¿{v}â‚ \\[-0.5em]
        n â‰  &\mathrel{} 0
      \end{alignat*}
    \end{minipage}}]
    {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
    \\ Ï,Ï„âŠ¢eâ‚ƒ,âˆ¿{Ïƒ}â‚â‡“âˆ¿{v},âˆ¿{Ïƒ}â‚‚}
    {  Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,âˆ¿{Ïƒ}â‡“âˆ¿{v},âˆ¿{Ïƒ}â‚‚}

    \inferrule*[left=(OBin)]
  {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
  \\ Ï,Ï„âŠ¢eâ‚‚,âˆ¿{Ïƒ}â‚â‡“âˆ¿{v}â‚‚,âˆ¿{Ïƒ}â‚‚}
  {  Ï,Ï„âŠ¢b(eâ‚,eâ‚‚),âˆ¿{Ïƒ}â‡“âˆ¿{âŸ¦bâŸ§}(âˆ¿{v}â‚,âˆ¿{v}â‚‚),âˆ¿{Ïƒ}â‚‚}

  \inferrule*[left=(ORefl)]{ }{Ï,Ï„âŠ¢e,âˆ¿{Ïƒ}â‡‘âŸ¨e,Ï,âˆ¿{Ïƒ},Ï„âŸ©}

  \inferrule*[left=(ORApp1)]
   {Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}
   {Ï,Ï„âŠ¢eâ‚(eâ‚‚),âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

   \inferrule*[left=(ORApp2),right={\ssmall Â«âŸ¨Î»x.eâ€²,Ïâ€²âŸ©âˆˆâˆ¿{v}â‚Â»}]
   {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
   \\ Ï,Ï„âŠ¢eâ‚‚,âˆ¿{Ïƒ}â‚â‡‘âˆ¿{Ï‚}}
   {Ï,Ï„âŠ¢eâ‚(eâ‚‚),âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

   \inferrule*[left=(ORApp3),right={\begin{minipage}{2em}\ssmall
       \begin{alignat*}{1}
       \begin{alignedat}{2} 
  âŸ¨Î»x.eâ€²,Ïâ€²âŸ© âˆˆ &\mathrel{} âˆ¿{v}â‚ \\[-0.5em]
           Ï„â€² = &\mathrel{} Ï„+1 \\[-0.5em]
           â„“  = &\mathrel{} âŸ¨x,Ï„â€²âŸ© \\
         \end{alignedat}
       \end{alignat*}
     \end{minipage}}]
  {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ} â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
  \\ Ï,Ï„âŠ¢eâ‚‚,âˆ¿{Ïƒ}â‚â‡“âˆ¿{v}â‚‚,âˆ¿{Ïƒ}â‚‚
  \\ Ïâ€²[xâ†¦â„“],Ï„â€²âŠ¢eâ€²,âˆ¿{Ïƒ}â‚‚âŠ”[â„“â†¦âˆ¿{v}â‚‚]â‡‘âˆ¿{Ï‚}}
  {Ï,Ï„âŠ¢eâ‚(eâ‚‚),âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

  \inferrule*[left=(ORIf1)]
  {Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}
  {Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

  \inferrule*[left=(ORIf-T),right={\ssmall Â«0âˆˆâˆ¿{v}â‚Â»}]
  {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
  \\ Ï,Ï„âŠ¢eâ‚‚,âˆ¿{Ïƒ}â‚â‡‘âˆ¿{Ï‚}}
  {Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

  \inferrule*[left=(ORIf-F),right={\begin{minipage}{2em}\ssmall 
    \begin{alignat*}{2}
      n âˆˆ &\mathrel{} âˆ¿{v}â‚ \\
      n â‰  &\mathrel{} 0
    \end{alignat*}
    \end{minipage}}]
    {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
    \\ Ï,Ï„âŠ¢eâ‚ƒ,âˆ¿{Ïƒ}â‚â‡‘âˆ¿{Ï‚}}
    {Ï,Ï„âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

  \inferrule*[left=(ORBin1)]
  {Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡‘Ï‚}
  {Ï,Ï„âŠ¢b(eâ‚,eâ‚‚),âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

  \inferrule*[left=(ORBin2)]
  {  Ï,Ï„âŠ¢eâ‚,âˆ¿{Ïƒ}â‡“âˆ¿{v}â‚,âˆ¿{Ïƒ}â‚
  \\ Ï,Ï„âŠ¢eâ‚‚,âˆ¿{Ïƒ}â‚â‡‘âˆ¿{Ï‚}}
  {Ï,Ï„âŠ¢b(eâ‚,eâ‚‚),âˆ¿{Ïƒ}â‡‘âˆ¿{Ï‚}}

\end{mathpar}
\caption{Big-step Collecting Reachability Semantics}
\end{figure} %}-}

The big-step collecting and reachability relations are structurally similar to
the concrete semantics. The primary differences are using set containment
(Â«âˆˆÂ») in place of equality (Â«=Â») when branching on application (Â«âŸ¨Î»x.e,ÏâŸ©Â» in
\textsc{(OApp)}) and conditional (Â«nâ‰Ÿ0Â» in \textsc{(OIf-T)} and
\textsc{(OIf-F)}) expressions, and updating the store with join
(Â«âˆ¿{Ïƒ}âŠ”[â„“â†¦âˆ¿{v}]Â») rather than strict replacement (Â«Ïƒ[â„“â†¦v]Â»).

The big-step collecting and reachability semantics is a sound approximation of
the big-step concrete and reachability semantics:
\begin{theorem}[Collecting and Reachability Semantics Soundness]
  Forall Â«eÂ», Â«ÏÂ», Â«ÏƒÂ», Â«Ï„Â», Â«vÂ», Â«Ïƒâ€²Â» and Â«Ï‚Â», if Â«Ï,Ï„âŠ¢e,Ïƒâ‡“v,Ïƒâ€²Â» then
  Â«Ï,Ï„âŠ¢e,Î·(Ïƒ)â‡“âˆ¿{v},âˆ¿{Ïƒ}â€²Â» for some Â«âˆ¿{v}Â» and Â«âˆ¿{Ïƒ}â€²Â» s.t. Â«vâˆˆâˆ¿{v}Â» and Â«Î·(Ïƒâ€²)
  âŠ‘ âˆ¿{Ïƒ}â€²Â»; and if Â«Ï,Ï„âŠ¢e,Ïƒâ‡‘Ï‚Â» then Â«Ï,Ï„âŠ¢e,Î·(Ïƒ)â‡‘âˆ¿{Ï‚}Â» for some Â«âˆ¿{Ï‚}Â» s.t.
  Â«Î·(Ï‚) âŠ‘ âˆ¿{Ï‚}Â».
\end{theorem}
The proof is a straightforward induction on the concrete big-step derivation.
The extraction function Â«Î·Â» is defined separately for stores (Â«ÏƒÂ») and
configurations (Â«Ï‚Â»):
\begin{alignat*}{1}
   & Î·(Ïƒ)(â„“) â‰” â´Ïƒ(â„“)âµ
\\ & Î·(âŸ¨e,Ï,Ïƒ,Ï„âŸ©) â‰” âŸ¨e,Ï,Î·(Ïƒ),Ï„âŸ©
\end{alignat*}
and the partial ordering on collecting stores and configurations is pointwise:
\begin{alignat*}{1}
  & âˆ¿{Ïƒ}â‚ âŠ‘ âˆ¿{Ïƒ}â‚‚ \quad \mathrel{â¦‘\emph{iff}â¦’} \quad âˆ€â„“.\mathrel{} âˆ¿{Ïƒ}â‚(â„“) âŠ† âˆ¿{Ïƒ}â‚‚(â„“)
  \\ & âŸ¨eâ‚,Ïâ‚,âˆ¿{Ïƒ}â‚,Ï„â‚âŸ© âŠ‘ âŸ¨eâ‚‚,Ïâ‚‚,âˆ¿{Ïƒ}â‚‚,Ï„â‚‚âŸ© \quad \mathrel{â¦‘\emph{iff}â¦’} 
  \\ & \hspace{1em} eâ‚ = eâ‚‚ âˆ§ Ïâ‚ = Ïâ‚‚ âˆ§ âˆ¿{Ïƒ}â‚ âŠ‘ âˆ¿{Ïƒ}â‚‚ âˆ§ Ï„â‚ = Ï„â‚‚
\end{alignat*}

\paragraph{Finite Abstraction}

The next step towards a computable static analysis is an abstract semantics
with a finite state space that approximates the big-step collecting semantics,
Â«â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡“â™¯{v},â™¯{Ïƒ}Â» and Â«â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡‘â™¯{Ï‚}Â», shown in
Figure~\ref{TODO}, where Â«â™¯{Ï}Â», Â«â™¯{Ï„}Â», Â«â™¯{v}Â», Â«â™¯{Ïƒ}Â» and Â«â™¯{Ï‚}Â» are finite
abstractions of their collecting counterparts:
\begin{alignat*}{3}
  â™¯{Ï} âˆˆ &&\mathrel{} â™¯{env}    &\mathrel{} â‰” var â†¦ â™¯{addr}â¸¤âŠ¥â¸¥ \\
  â™¯{â„“} âˆˆ &&\mathrel{} â™¯{addr}   &\mathrel{} â‰” var Ã— â™¯{time} \\
  â™¯{Ï„} âˆˆ &&\mathrel{} â™¯{time}   &\mathrel{} â‰” â€¦ \\
  â™¯{v} âˆˆ &&\mathrel{} â™¯{val}    &\mathrel{} â‰” â€¦ \\
  â™¯{Ïƒ} âˆˆ &&\mathrel{} â™¯{store}  &\mathrel{} â‰” â™¯{addr} â†¦ â™¯{val} \\
  â™¯{Ï‚} âˆˆ &&\mathrel{} â™¯{config} &\mathrel{} â‰” exp Ã— â™¯{env} Ã— â™¯{store} Ã— â™¯{time}
\end{alignat*}
and the abstract denotation (Â«â™¯{âŸ¦bâŸ§}Â») is an overapproximation of the collecting
denotation (Â«âˆ¿{âŸ¦bâŸ§}Â») w.r.t. a Galois connection Â«âˆ¿{val}â‡„{Î±}{Î³}â™¯{val}Â»:
\[ â™¯{âŸ¦bâŸ§}(â™¯{v}â‚,â™¯{v}â‚‚) âŠ’ Î±(âˆ¿{âŸ¦bâŸ§}(Î³(â™¯{v}â‚),Î³(â™¯{v}â‚‚))) \]
Concretization functions Â«âŒŠÎ³âŒ‹â¸¤cloâ¸¥Â», Â«âŒŠÎ³âŒ‹â¸¤0â¸¥Â» and Â«âŒŠÎ³âŒ‹â¸¤Â¬0â¸¥Â» are computable
finite subsets of the full concretization function Â«Î³Â» s.t.:
\begin{alignat*}{1}
  & âŒŠÎ³âŒ‹â¸¤cloâ¸¥(â™¯{v}) â‰” â´âŸ¨Î»x.e,â™¯{Ï}âŸ© âˆ£ âŸ¨Î»x.e,â™¯{Ï}âŸ© âˆˆ Î³(â™¯{v})âµ \\
  & âŒŠÎ³âŒ‹â¸¤0â¸¥(â™¯{v}) â‰” â´0 âˆ£ 0 âˆˆ Î³(â™¯{v})âµ \\
  & âŒŠÎ³âŒ‹â¸¤Â¬0â¸¥(â™¯{v}) â‰” â´Â¬0 âˆ£ n âˆˆ Î³(â™¯{v}) âˆ§ nâ‰ 0âµ
\end{alignat*}
Abstract sets Â«â™¯{time}Â» and Â«â™¯{val}Â» are left as parameters to the analysis
along with their operations Â«â™¯{next}Â», Â«â™¯{âŸ¦bâŸ§}Â», Â«âŒŠÎ³âŒ‹â¸¤cloâ¸¥Â», Â«âŒŠÎ³âŒ‹â¸¤0â¸¥Â»,
Â«âŒŠÎ³âŒ‹â¸¤Â¬0â¸¥Â» and Â«âŠ”â¸¢â™¯{val}â¸£Â».

\begin{figure} %{-{
\begin{mathpar}
  \inferrule*[left=(ALit)]{ }{â™¯{Ï},â™¯{Ï„}âŠ¢n,â™¯{Ïƒ}â‡“â™¯{Î·}(n),â™¯{Ïƒ}}

  \inferrule*[left=(AVar)]{ }{â™¯{Ï},â™¯{Ï„}âŠ¢x,â™¯{Ïƒ}â‡“â™¯{Ïƒ}(â™¯{Ï}(x)),â™¯{Ïƒ}}

  \inferrule*[left=(ALam)]{ }{â™¯{Ï},â™¯{Ï„}âŠ¢Î»x.e,â™¯{Ïƒ}â‡“â™¯{Î·}(âŸ¨Î»x.e,â™¯{Ï}âŸ©),â™¯{Ïƒ}}

  \inferrule*[left=(AApp),right={\begin{minipage}{2em}\ssmall
    \begin{alignat*}{1}
    \begin{alignedat}{2} 
           âŸ¨Î»x.eâ€²,â™¯{Ï}â€²âŸ© âˆˆ &\mathrel{} âŒŠÎ³âŒ‹â¸¤cloâ¸¥(â™¯{v}â‚) \\[-0.5em]
                   â™¯{Ï‚}  = &\mathrel{} âŸ¨eâ‚(eâ‚‚),â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ© \\[-0.5em]
                   â™¯{Ï„}â€² = &\mathrel{} â™¯{next}(â™¯{Ï„},â™¯{Ï‚}) \\[-0.5em]
                   â™¯{â„“}  = &\mathrel{} âŸ¨x,â™¯{Ï„}â€²âŸ©
      \end{alignedat}
    \end{alignat*}
  \end{minipage}}]
  {  â™¯{Ï}      ,â™¯{Ï„} âŠ¢eâ‚    ,â™¯{Ïƒ} â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
  \\ â™¯{Ï}      ,â™¯{Ï„} âŠ¢eâ‚‚    ,â™¯{Ïƒ}â‚â‡“â™¯{v}â‚‚,â™¯{Ïƒ}â‚‚
  \\ â™¯{Ï}â€²[xâ†¦â™¯{â„“}],â™¯{Ï„}â€²âŠ¢eâ€²    ,â™¯{Ïƒ}â‚‚âŠ”[â™¯{â„“}â†¦â™¯{v}â‚‚]â‡“â™¯{v}â€²,â™¯{Ïƒ}â‚ƒ}
  {â™¯{Ï}      ,â™¯{Ï„} âŠ¢eâ‚(eâ‚‚),â™¯{Ïƒ} â‡“â™¯{v}â€²,â™¯{Ïƒ}â‚ƒ}

  \inferrule*[left=(AIf-T),right={\ssmall Â«0âˆˆâŒŠÎ³âŒ‹â¸¤0â¸¥(â™¯{v}â‚)Â»}]
  {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
  \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚‚,â™¯{Ïƒ}â‚â‡“â™¯{v},â™¯{Ïƒ}â‚‚}
  {  â™¯{Ï},â™¯{Ï„}âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,â™¯{Ïƒ}â‡“â™¯{v},â™¯{Ïƒ}â‚‚}

  \inferrule*[left=(AIf-F),right={\ssmall Â«Â¬0âˆˆâŒŠÎ³âŒ‹â¸¤Â¬0â¸¥(â™¯{v}â‚)Â»}]
  {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
  \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚ƒ,â™¯{Ïƒ}â‚â‡“â™¯{v},â™¯{Ïƒ}â‚‚}
  {  â™¯{Ï},â™¯{Ï„}âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,â™¯{Ïƒ}â‡“â™¯{v},â™¯{Ïƒ}â‚‚}

    \inferrule*[left=(ABin)]
    {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
    \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚‚,â™¯{Ïƒ}â‚â‡“â™¯{v}â‚‚,â™¯{Ïƒ}â‚‚}
    {  â™¯{Ï},â™¯{Ï„}âŠ¢b(eâ‚,eâ‚‚),â™¯{Ïƒ}â‡“â™¯{âŸ¦bâŸ§}(â™¯{v}â‚,â™¯{v}â‚‚),â™¯{Ïƒ}â‚‚}

    \inferrule*[left=(ARefl)]{ }{â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡‘âŸ¨e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ©}

  \inferrule*[left=(ARApp1)]
  {â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡‘â™¯{Ï‚}}
  {â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚(eâ‚‚),â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

  \inferrule*[left=(ARApp2),right={\ssmall Â«âŸ¨Î»x.eâ€²,â™¯{Ï}â€²âŸ©âˆˆâŒŠÎ³âŒ‹â¸¤cloâ¸¥(â™¯{v}â‚)Â»}]
  {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
  \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚‚,â™¯{Ïƒ}â‚â‡‘â™¯{Ï‚}}
  {â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚(eâ‚‚),â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

   \inferrule*[left=(ARApp3),right={\begin{minipage}{2em}\ssmall
       \begin{alignat*}{1}
       \begin{alignedat}{2} 
         âŸ¨Î»x.eâ€²,â™¯{Ï}â€²âŸ© âˆˆ &\mathrel{} âŒŠÎ³âŒ‹â¸¤cloâ¸¥(â™¯{v}â‚) \\[-0.5em]
            â™¯{Ï‚} = &\mathrel{} âŸ¨eâ‚(eâ‚‚),â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ© \\[-0.5em]
           â™¯{Ï„}â€² = &\mathrel{} â™¯{next}(â™¯{Ï„},â™¯{Ï‚}) \\[-0.5em]
           â™¯{â„“}  = &\mathrel{} âŸ¨x,â™¯{Ï„}â€²âŸ© \\
         \end{alignedat}
       \end{alignat*}
     \end{minipage}}]
     {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ} â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
       \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚‚,â™¯{Ïƒ}â‚â‡“â™¯{v}â‚‚,â™¯{Ïƒ}â‚‚
     \\ â™¯{Ï}â€²[xâ†¦â™¯{â„“}],â™¯{Ï„}â€²âŠ¢eâ€²,â™¯{Ïƒ}â‚‚âŠ”[â™¯{â„“}â†¦â™¯{v}â‚‚]â‡‘â™¯{Ï‚}}
     {â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚(eâ‚‚),â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

  \inferrule*[left=(ARIf1)]
  {â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡‘â™¯{Ï‚}}
  {â™¯{Ï},â™¯{Ï„}âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

  \inferrule*[left=(ARIf-T),right={\ssmall Â«0âˆˆâŒŠÎ³âŒ‹â¸¤0â¸¥(â™¯{v}â‚)Â»}]
  {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
  \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚‚,â™¯{Ïƒ}â‚â‡‘â™¯{Ï‚}}
  {â™¯{Ï},â™¯{Ï„}âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

  \inferrule*[left=(ARIf-F),right={\ssmall Â«Â¬0âˆˆâŒŠÎ³âŒ‹â¸¤Â¬0â¸¥(â™¯{v}â‚)Â»}]
    {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
    \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚ƒ,â™¯{Ïƒ}â‚â‡‘â™¯{Ï‚}}
    {â™¯{Ï},â™¯{Ï„}âŠ¢âŸ¬if0âŸ­(eâ‚)â´eâ‚‚âµâ´eâ‚ƒâµ,â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

  \inferrule*[left=(ARBin1)]
  {â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡‘Ï‚}
  {â™¯{Ï},â™¯{Ï„}âŠ¢b(eâ‚,eâ‚‚),â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

  \inferrule*[left=(ARBin2)]
  {  â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚,â™¯{Ïƒ}â‡“â™¯{v}â‚,â™¯{Ïƒ}â‚
  \\ â™¯{Ï},â™¯{Ï„}âŠ¢eâ‚‚,â™¯{Ïƒ}â‚â‡‘â™¯{Ï‚}}
  {â™¯{Ï},â™¯{Ï„}âŠ¢b(eâ‚,eâ‚‚),â™¯{Ïƒ}â‡‘â™¯{Ï‚}}

\end{mathpar}
\caption{Big-step Abstract Reachability Semantics}
\end{figure} %}-}

\paragraph{Computing the Analysis}

An analysis for the program Â«eâ‚€Â» w.r.t. the abstract semantics is some cache
Â«\$ âˆˆ â™¯{config} â†¦ â„˜(â™¯{val} Ã— â™¯{store})Â» that maps all configurations reachable
from the initial configuration Â«âŸ¨eâ‚€,â™¯{Ï}â‚€,â™¯{Ïƒ}â‚€,â™¯{Ï„}â‚€âŸ©Â» to their final values
and stores Â«â™¯{v},â™¯{Ïƒ}Â», which we notate Â«\$ âŠ¨ eâ‚€Â»:
\begin{alignat*}{2}
  \$ âŠ¨ eâ‚€ \quad\quad \mathrel{â¦‘\emph{iff}â¦’} \quad\quad & 
    \begin{alignedat}{2}
    â¦‘\emph{forall}â¦’ & \mathrel{} e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„},â™¯{v},â™¯{Ïƒ}â€²: \\
    â¦‘\emph{if}â¦’     & \mathrel{} â™¯{Ï}â‚€,â™¯{Ï„}â‚€âŠ¢eâ‚€,â™¯{Ïƒâ‚€}â‡‘âŸ¨e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ© \\
    â¦‘\emph{and}â¦’    & \mathrel{} â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡“â™¯{v},â™¯{Ïƒ}â€²  \\ 
    â¦‘\emph{then}â¦’   & \mathrel{} âŸ¨â™¯{v},â™¯{Ïƒ}â€²âŸ© âˆˆ \$(âŸ¨e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ©)
      \end{alignedat}
\end{alignat*}
The best cache Â«\$âºÂ» is then computed as the least fixed point of the
functional Â«â„±Â»:
\begin{alignat*}{1}
  & â„± âˆˆ (â™¯{config} â†¦ â„˜(â™¯{val}Ã—â™¯{store})) â†’ (â™¯{config} â†¦ â„˜(â™¯{val}Ã—â™¯{store})) \\
  & â„± â‰” Î»\$.  \\
  &  \hspace{1em} â¨†â¸¤âŸ¨e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ©âˆˆ\$â¸¥ \begin{cases}
     â´ âŸ¨e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ© â†¦ â´âŸ¨â™¯{v},â™¯{Ïƒ}â€²âŸ©âµ âˆ£ â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡“â¸¢\$â¸£â™¯{v},â™¯{Ïƒ}â€² âµ \\
     â´ â™¯{Ï‚} â†¦ â´âµ âˆ£ â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡‘â¸¢\$â¸£â™¯{Ï‚}âµ
   \end{cases} \\
\end{alignat*}
and defined:
\[ \$âº â‰” â¦‘\emph{lfp}â¦’ (Î»\$.\mathrel{} â„±(\$)  âŠ” â´âŸ¨eâ‚€,â™¯{Ï}â‚€,â™¯{Ïƒ}â‚€,â™¯{Ï„}â‚€âŸ© â†¦ â´âµâµ) \]
The relations Â«â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡“â¸¢\$â¸£â™¯{v},â™¯{Ïƒ}â€²Â» and Â«â™¯{Ï},â™¯{Ï„}âŠ¢e,â™¯{Ïƒ}â‡‘â¸¢\$â¸£â™¯{Ï‚}Â»
are modified versions of the original abstract semantics, but with recursive
judgements replaced by Â«âŸ¨â™¯{v},â™¯{Ïƒ}âŸ© âˆˆ \$(e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„})Â» and Â«â™¯{Ï‚} âˆˆ
\$(e,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„})Â» respectively. Therefore Â«â„±Â» is not recursive; the
recursion in the relations is lifted to the outer fixpoint of the analysis.
Because the state space Â«â™¯{config} â†¦ â„˜(â™¯{val}Ã—â™¯{store})Â» is finite and Â«â„±Â» is
monotonic, Â«\$âºÂ» can be computed algorithmically in finite time by a simple
Kleene fixed-point iteration. See Nielson et al~\cite{TOOD} for more background
and examples of static analyzers computed in this style, and from which the
current development was largely inspired.

\paragraph{Computing with Definitional Interpreters}

The algorithm described in Section~\ref{TODO} is a more efficient strategy for
computing Â«\$âºÂ» using an extensible open-recursive definitional interpreter.
This technique is general, and bridges the gap between the big-step abstract
semantics formalized in this section and the definitional interpreters we wish
to execute to obtain analyses.

An extensible open-recursive definitional interpreter for \lamif (the small
language formalized in this section) has domain:
\begin{alignat*}{1}
  & â„° âˆˆ Î£ â†’ Î£ \quad â¦‘\emph{where}â¦’ \quad Î£ â‰” â™¯{config} â†’ â„˜(â™¯{val}Ã—â™¯{store})
\end{alignat*}
and is defined such that its denotational-fixpoint (Â«Y(â„°)Â») recovers concrete
interpretation when instantiated with the concrete state-space. For example,
the recursive case for binary operator expressions is defined:
\begin{alignat*}{1}
  & â„°(â„°â€²)(âŸ¨b(eâ‚,eâ‚‚),â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}) â‰”  \\
  & \hspace{1em} â´\mathrel{} â™¯{âŸ¦bâŸ§}(â™¯{v}â‚,â™¯{vâ‚‚}) \\
  & \hspace{1em} âˆ£\mathrel{} âŸ¨â™¯{v}â‚,â™¯{Ïƒ}â‚âŸ© âˆˆ â„°â€²(âŸ¨eâ‚,â™¯{Ï},â™¯{Ïƒ},â™¯{Ï„}âŸ©) âˆ§ âŸ¨â™¯{v}â‚‚,â™¯{Ïƒ}â‚‚âŸ© âˆˆ â„°â€²(âŸ¨eâ‚‚,â™¯{Ï},â™¯{Ïƒ}â‚,â™¯{Ï„}âŸ©) âµ
\end{alignat*}
The iteration strategy to analyze the program Â«eâ‚€Â» is then to run Â«eâ‚€Â» using
Â«â„°Â», but intercepting recursive calls to:
\begin{enumerate}
  \item cache results for all intermediate configurations Â«â™¯{Ï‚}Â», and
  \item cache seen states to prevent infinite loops.
\end{enumerate}
(1) is required to fulfill the specification that Â«\$âºÂ» include results for all
reachable configurations from Â«eâ‚€Â», and (2) is required to reach a fixed point
of the analysis. To track this extra information we add functional state to the
interpreter (which was done through a monad transformer in the tutorial
development) of type:
\[ â™¯{cache} â‰” â™¯{config} â†¦ â„˜(â™¯{val}Ã—â™¯{store}) \]
such that the open-recursive evaluator has type:
\begin{alignat*}{1}
  & â„° âˆˆ Î£ â†’ Î£ \quad â¦‘\emph{where}â¦’ \\
  & \hspace{1em} Î£ â‰” â™¯{config}Ã—â™¯{cache} â†’ â„˜(â™¯{val}Ã—â™¯{store})Ã—â™¯{cache}
\end{alignat*}
The iteration to compute Â«\$âºÂ» given Â«â„°Â» is then defined:
\begin{alignat*}{1}
  & \hspace{0em} \$âº â‰” â¦‘\emph{lfp}â¦’(Î»\$áµ’. \\
  & \hspace{1em} \mathrel{âŸ¬letâŸ­} â„°â‹† â‰” Y(Î»â„°â€². \\
  & \hspace{2em}    â„°(Î»âŸ¨â™¯{Ï‚},\$â±âŸ©. \\
  & \hspace{3em}      \mathrel{âŸ¬ifâŸ­} â™¯{Ï‚} âˆˆ \$â± \mathrel{âŸ¬thenâŸ­} âŸ¨\$â±(â™¯{Ï‚}),\$â±âŸ© \mathrel{âŸ¬elseâŸ­} \\
  & \hspace{3em}      \mathrel{âŸ¬letâŸ­} âŸ¨â™¯{VS},\$â¸¢i\primeâ¸£âŸ© â‰” â„°â€²(â™¯{Ï‚},\$â±[â™¯{Ï‚}â†¦\$áµ’(â™¯{Ï‚})]) \\
  & \hspace{3em}      \mathrel{âŸ¬inâŸ­} âŸ¨â™¯{VS},\$â¸¢i\primeâ¸£[â™¯{Ï‚}â†¦â™¯{VS}]âŸ©)) \\
  & \hspace{1em} \mathrel{âŸ¬inâŸ­} Ï€â‚‚(â„°â‹†(âŸ¨eâ‚€,â™¯{Ï}â‚€,â™¯{Ïƒ}â‚€,â™¯{Ï„}â‚€âŸ©,â´âµ)))
\end{alignat*}
The fixed interpreter Â«â„°â‹†Â» calls the unfixed interpreter Â«â„°Â», but intercepts
recursive calls to perform (1) and (2) described above. When loops are
detected, the results from the previous complete result Â«\$áµ’Â» is used, and the
outer fixpoint of the algorithm computes the least fixed point of this Â«\$áµ’Â».

The end result is that, rather than compute analysis results and reachable
states naively with Kleene fixpoint iteration, we are able to reuse the
standard definitional interpreterâ€”written in open-recursive formâ€”to
simultaneously explore reachable states, cache intermediate configurations, and
iterate towards a least fixpoint solution for the analysis. This method is more
efficient, and reuses an extensible definitional interpreter which can recover
a wide range of analyses, including concrete interpretation.

\paragraph{Widening}

Two forms of widening can be employed to the semantics and iteration algorithm
to achieve acceptable performance for the abstract interpreter.

The first form of widening is to widen the store in the result set
Â«â„˜(â™¯{val}Ã—â™¯{store})Â» to Â«â„˜(â™¯{val})Ã—â™¯{store}Â» in the evaluator Â«â„°Â»:
\begin{alignat*}{1}
  & â„° âˆˆ Î£ â†’ Î£ \quad â¦‘\emph{where}â¦’ \\
  & \hspace{1em} Î£ â‰” â™¯{config} Ã— â™¯{cache} â†’ â„˜(â™¯{val})Ã—â™¯{store}Ã—â™¯{cache}
\end{alignat*}
We perform this widening systematically and with no added effort through the
use of Galois Transformers in Section~\ref{TODO}. The iteration strategy for
this widened state space is the same as before, which computes a fixed point of
the outer cache Â«\$áµ’Â».

The next form of widening is to pull the store out of the configuration space
\emph{entirely}, that is:
\begin{alignat*}{2}
  â™¯{Ï‚} âˆˆ &\mathrel{} â™¯{config} â‰” exp Ã— â™¯{env} Ã— â™¯{time} \\
    \$ âˆˆ &\mathrel{} â™¯{cache} â‰” â™¯{config} â†¦ â„˜(â™¯{val})
\end{alignat*}
and
\begin{alignat*}{1}
  & â„° âˆˆ Î£ â†’ Î£ \quad â¦‘\emph{where}â¦’ \\
  & \hspace{1em} Î£ â‰” â™¯{config}Ã—â™¯{store}Ã—â™¯{cache} â†’ ğ’«(â™¯{val})Ã—â™¯{store}Ã—â™¯{cache}
\end{alignat*}
The fixed point iteration then finds a mutual least fixed-point of both the
outer cache Â«\$áµ’Â» \emph{and} the store Â«â™¯{Ïƒ}Â»:
\begin{alignat*}{1}
  & \hspace{0em} âŸ¨\$âº,â™¯{Ïƒ}âºâŸ© â‰” â¦‘\emph{lfp}â¦’(Î»âŸ¨\$áµ’,â™¯{Ïƒ}âŸ©. \\
  & \hspace{1em} \mathrel{âŸ¬letâŸ­} â„°â‹† â‰” Y(Î»â„°â€². \\
  & \hspace{2em}    â„°(Î»âŸ¨â™¯{Ï‚},â™¯{Ïƒ}â±,\$â±âŸ©. \\
  & \hspace{3em}      \mathrel{âŸ¬ifâŸ­} â™¯{Ï‚} âˆˆ \$â± \mathrel{âŸ¬thenâŸ­} âŸ¨\$â±(â™¯{Ï‚}),Ïƒâ±,\$â±âŸ© \mathrel{âŸ¬elseâŸ­} \\
  & \hspace{3em}      \mathrel{âŸ¬letâŸ­} âŸ¨â™¯{V},â™¯{Ïƒ}â¸¢i\primeâ¸£,\$â¸¢i\primeâ¸£âŸ© â‰” â„°â€²(â™¯{Ï‚},â™¯{Ïƒ}â±,\$â±[â™¯{Ï‚}â†¦\$áµ’(â™¯{Ï‚})]) \\
  & \hspace{3em}      \mathrel{âŸ¬inâŸ­} âŸ¨â™¯{V},â™¯{Ïƒ}â¸¢i\primeâ¸£,\$â¸¢i\primeâ¸£[â™¯{Ï‚}â†¦â™¯{V}]âŸ©)) \\
  & \hspace{1em} \mathrel{âŸ¬inâŸ­} Ï€â¸¤2Ã—3â¸¥(â„°â‹†(âŸ¨eâ‚€,â™¯{Ï}â‚€,â™¯{Ï„}â‚€âŸ©,â™¯{Ïƒ},â´âµ)))
\end{alignat*}
This second version of widening, which computes a fixpoint also over the store,
recovers a so-called \emph{flow-insensitive} analysis. In this model, all
program states are re-analyzed in the store resulting from execution. Also, the
cache (Â«\$Â») does not index over store states Â«â™¯{Ïƒ}Â» in its domain, greatly
reducing its size, and leading to a much more efficient (although less precise)
static analyzer.

\paragraph{Recovering Classical 0CFA}

From the fully widened static analyzer, which computes a mutual fixpoint
between a cache and store, we can easily recover a classical 0CFA analysis. We
do this by instantiating Â«â™¯{time}Â» to the singleton abstraction Â«â´â€¢âµÂ», as was
shown in the original work on AAM~\cite{TODO}. In this setting, the lexical
environment Â«ÏÂ» is uniquely determined by the program expression Â«eÂ», and can
therefore be eliminated, resulting in the analysis state space:
\begin{alignat*}{2}
  â™¯{Ï‚} âˆˆ &\mathrel{} â™¯{config} â‰” exp \\
    \$ âˆˆ &\mathrel{} â™¯{cache} â‰” exp â†¦ â„˜(â™¯{val})
\end{alignat*}
The specification for the analysis and the fully store-widened least
fixed-point iteration for computing it recovers the constraint-based
description of 0CFA given by Nielson \emph{et al} in~\cite{TODO}, where 0CFA is
defined as the smallest cache (Â«\$Â») and store (Â«ÏƒÂ») which satisfy a
co-inductively defined judgment:
\[ \$,Ïƒ âŠ¨ e \]

\paragraph{Recovering Pushdown Analysis}

We borrow from the recent result in pushdown analysis~\cite{TODO} which shows
that full pushdown precision can be achieved in a small-step store-widened
abstract semantics by allocating continuations using the address space of
program expressions paired with abstract environments (Â«âŸ¨e,â™¯{Ï}âŸ©Â»). In other
words, Â«âŸ¨e,â™¯{Ï}âŸ©Â» is sufficient to achieve full pushdown precision because
the tuple uniquely identifies the evaluation context up to the final result of
evaluation.

Our fully widened semantics recovers this pushdown setting because the
cache maps tuples Â«âŸ¨e,â™¯{Ï},â™¯{Ï„}âŸ©Â», which trivially contains Â«âŸ¨e,â™¯{Ï}âŸ©Â».
Furthermore, we can immediately see that the abstract time component Â«â™¯{Ï„}Â» is
redundant, and can eliminate it from the cache, resulting in analysis state
space:
\begin{alignat*}{2}
  â™¯{Ï‚} âˆˆ &\mathrel{} â™¯{config} â‰” exp Ã— â™¯{env} Ã— â™¯{time} \\
  \$ âˆˆ &\mathrel{} â™¯{cache} â‰” exp Ã— â™¯{env} â†¦ â„˜(â™¯{val})
\end{alignat*}

An advantage of our setting is that we recover pushdown analysis also for
varying degrees of store-widening, which is not the case in Gilray \emph{et
al}~\ref{TODO}, although pushdown precision for non-widened semantics has been
shown before in Johnson and Van Horn~\ref{TODO:AAC}. Furthermore, the
implementation of our analyzer achieves this precision by precise call-return
matching in the defining metalanguage of a definitional interpreter, requiring
no added instrumentation to the state-space of the analyzer.

Going back to Nielson et al~\cite{TODO}, it would be interesting to redevelop
their constraint-based analysis descriptions of kCFA in a form that
recovers pushdown precision. Such an exercise would amount to translating our
big-step abstract semantics instantiated to kCFA to a constraint system. The
resulting system would differ from classical kCFA by the addition of
environments Â«â™¯{Ï}Â» (which Nielson et al call context environments) to the
domain of the cache. In this way our formal framework is able to bridge the gap
between results in pushdown analysis described via small-step machines \emph{a
la} Van Horn and Might~\cite{TODO}, and constraint-based systems \emph{a la}
Nielson et al~\cite{TODO} for which pushdown analysis has yet to be described
effectively.
