\section{Path Sensitivity}\label{s:symbolic}

As a final exercise in applying our definitional abstract interpretation
framework, we develop a symbolic execution engine, and use it to perform sound
program verification. First we describe the monad stack and metafunctions that
implement a symbolic executor~\cite{dvanhorn:King1976Symbolic}, then show how
abstractions discussed in previous sections can be applied to enforce
termination, turning a traditional symbolic execution into a path-sensitive
verification engine.

\subsection{Symbolic Execution}
To support symbolic execution, first we extend the syntax of the language to
support symbolic numbers:
\begin{alignat*}{4}
   e âˆˆ &&\mathrel{}     exp â©´ &\mathrel{} â€¦ âˆ£ ğ”¥â¸¨(symâ¸©\ xğ”¥â¸¨)â¸© &\hspace{1em} [â¦‘\emph{symbolic number}â¦’]
\\ Îµ âˆˆ &&\mathrel{}    pexp â©´ &\mathrel{} e âˆ£ Â¬e             &\hspace{1em} [â¦‘\emph{path expression}â¦’]
\\ Ï† âˆˆ &&\mathrel{}    pcon â‰” &\mathrel{} â„˜(pexp)   &\hspace{1em} [â¦‘\emph{path condition}â¦’]
\end{alignat*}
Figure~\ref{s:symbolic} shows the units needed to turn the existing interpreter
into a symbolic executor. Primitives such as â¸¨'/â¸© now also take as input and
return symbolic values. As standard, symbolic execution employs a
path-condition accumulating assumptions made at each branch, allowing the
elimination of infeasible paths and construction of test cases. We represent
the path-condition â¸¨Ï†â¸© as a set of symbolic values or their negations.
If â¸¨eâ¸© is in â¸¨Ï†â¸©, â¸¨eâ¸© is assumed to evaluate to â¸¨0â¸©;
if â¸¨Â¬ eâ¸© is in â¸¨Ï†â¸©, â¸¨eâ¸© is assumed to evaluate to non-â¸¨0â¸©.
This set is another state component provided by â¸¨StateTâ¸© in the monad
transformer stack. Monadic operations â¸¨get-path-condâ¸© and â¸¨refineâ¸© reference
and update the path-condition. The metafunction â¸¨zero?â¸© works similarly to the
concrete counterpart, but also uses the path-condition to prove that some
symbolic numbers are definitely â¸¨0â¸© or non-â¸¨0â¸©. In case of uncertainty, â¸¨zero?â¸©
returns both answers instead of refining the path-condition with the assumption
made.

In the following example, the symbolic executor recognizes that result â¸¨3â¸© and
division-by-0 error are not feasible:
â„‘â…
Â¦ > (if0 'x (if0 'x 2 3) (/ 5 'x))
â„‘,
Â¦ (set (cons '(/ 5 x) (set '(Â¬ x)))
Â¦      (cons 2 (set 'x)))
â„‘â†
A scaled up symbolic executor could implement â¸¨zero?â¸© by calling out to an SMT
solver for interesting arithmetics, or extend the language with symbolic
functions and blame semantics for sound higher-order symbolic
execution~\cite{dvanhorn:TobinHochstadt2012Higherorder,dvanhorn:Nguyen2015Relatively}.

\begin{figure} %{-{
\rfloat{â¸¨Î´^-symbolic@â¸©}
\begin{lstlisting}
Â¦ (define (Î´ o nâ‚€ nâ‚)
Â¦   (match* (o nâ‚€ nâ‚)
Â¦     [('/ nâ‚€ nâ‚)
Â¦      (do z? â† (zero? nâ‚)
Â¦          (cond [z? fail]
Â¦                [(member 'N (list nâ‚€ nâ‚))
Â¦                 (return 'N)] ... ))])] ... ))
Â¦ (define (zero? v)
Â¦   (do Ï† â† get-path-cond
Â¦       (match v 
Â¦         ['N (mplus (return #t) (return #f))] ... )))
\end{lstlisting}
\vspace{-0.75em}
\caption{Symbolic Execution with Abstract Numbers}
\label{f:symbolic-widen}
\vspace{-1em}
\end{figure} %}-}

\subsection{From Symbolic Execution to Verification}

Traditional symbolic executors mainly aim to find bugs and do not provide
termination guarantee. However, when we apply to this symbolic executor the
finite abstractions presented in previous sections, namely base value widening
and finite allocation (Section~\ref{s:base}), and caching and fixing
(Section~\ref{s:cache}), we turn the symbolic execution into a sound,
path-sensitive program verification.

Operations on symbolic values introduce a new source of infinity in the
state-space, because the space of symbolic values is not finite. We therefore
widen a symbolic value to the abstract number â¸¨'Nâ¸© when it shares an address
with a different number, similarly to the precision-preserving abstraction from
Section~\ref{s:alt-abstraction}. Figure~\ref{f:symbolic-widen} shows extension
to â¸¨Î´â¸© and â¸¨zero?â¸© in the presence of â¸¨'Nâ¸©. The different treatments of â¸¨'Nâ¸©
and symbolic values clarifies that abstract values are not symbolic values: the
former stands for a set of multiple values, whereas the latter stands for an
single unknown value. Tests on abstract number â¸¨'Nâ¸© do not strengthen the
path-condition; it is unsound to accumulate any assumption about â¸¨'Nâ¸©.

