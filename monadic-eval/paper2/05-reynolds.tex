\section{Pushdown \emph{à la} Reynolds}\label{s:reynolds}

\begin{figure} %{-{
\rfloat{⸨fix-cache@⸩}
\begin{lstlisting}
¦ (define ((fix-cache eval) e)  
¦   (do ρ ← ask-env  σ ← get-store
¦       ς ≔ (list e ρ σ)
¦       ¢⁺ ← (mlfp (λ (¢) (do (put-cache-out ∅)
¦                             (put-store σ)
¦                             (local-cache-in ¢ (eval e))
¦                             get-cache-out)))
¦       (for/monad+ ([v×σ (¢⁺ ς)])
¦         (do (put-store (cdr v×σ))
¦             (return (car v×σ))))))
¦ (define (mlfp f)
¦   (let loop ([x ∅])
¦     (do x′ ← (f x)
¦         (if (equal? x′ x) (return x) (loop x′)))))
\end{lstlisting}
\captionskip{Finding Fixpoints in the Cache}
\label{f:fixing}
\end{figure} %}-}

By combining the finite abstraction of base values and closures with the
termination-guaranteeing cache-based fixed-point algorithm, we have obtained a
terminating abstract interpreter.  But what kind of abstract interpretation did
we get?

We have followed the basic recipe of AAM, but adapted to a compositional
evaluator instead of an abstract machine.  However, we did manage to skip over
one of the key steps in the AAM method: we never store-allocated continuations.
\begin{center}
\emph{In fact, there are no continuations at all!}
\end{center}
The abstract machine formulation of the semantics models the object-level stack
explicitly as an inductively defined data structure.  Because stacks may be
arbitrarily large, they must be finitized like base values and closures.  Like
closures, the AAM trick is to thread them through the store and then finitize
the store.  But in the definitional interpreter approach, the stack is implicit
and inherited from the meta-language.

But here is the remarkable thing: since the stack is inherited from the
meta-language, the abstract interpreter inherits the ``call-return matching''
of the meta-language, which is to say there is no loss of precision of in the
analysis of the control stack.  This is a property that usually comes at
considerable effort and engineering in the formulations of higher-order flow
analysis that model the stack explicitly.  So-called higher-order ``pushdown''
analysis has been the subject of multiple publications and a
dissertation~\cite%
{dvanhorn:Vardoulakis2011CFA2%
,dvanhorn:Earl2010Pushdown%
,local:vardoulakis-diss12%
,dvanhorn:VanHorn2012Systematic%
,dvanhorn:Earl2012Introspective%
,dvanhorn:Johnson2014Abstracting%
,dvanhorn:Johnson2014Pushdown%
,local:p4f%
}. Yet when formulated in the definitional interpreter style, the pushdown
property requires no mechanics and is simply inherited from the meta-language.

Reynolds, in his celebrated paper \emph{Definitional Interpreters for
Higher-order Programming Languages}~\cite{dvanhorn:reynolds-acm72}, first
observed that when the semantics of a programming language is presented as a
definitional interpreter, the defined language could inherit semantic
properties of the defining metalanguage.  We have now shown this observation
can be extended to \emph{abstract} interpretation as well, namely in the
important case of the pushdown property.

In the remainder of this paper, we explore a few natural extensions and
variations on the basic pushdown abstract interpreter we have established up to
this point.
