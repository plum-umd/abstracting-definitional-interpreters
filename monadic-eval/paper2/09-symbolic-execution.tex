\section{Symbolic Execution and Path-sensitive Verification}\label{s:symbolic}

As a final exercise in abstract interpretation component engineering, we
develop a monadic view of symbolic execution.

We present an extension to the monad stack and metafunctions that gives rise to
a symbolic executor~\cite{dvanhorn:King1976Symbolic}, then show how
abstractions discussed in previous sections can be applied to enforce
termination, turning a traditional symbolic execution into a path-sensitive
verification engine.

\subsection{Symbolic Execution}
Figure~\ref{s:symbolic} shows the units needed to turn the existing interpreter
into a symbolic executor, in addition to adding symbolic numbers â¸¨(sym X)â¸©
to the language syntax.
Primitives such as â¸¨'/â¸© now may also take as input
and return symbolic values.
As standard, symbolic execution employs a path-condition
accumulating assumptions made at each branch,
allowing the elimination of infeasible paths and construction of test cases.
We represent the path-condition â¸¨Ï†â¸© as a set of symbolic values
known to have evaluated to â¸¨0â¸©.
This set is another state component provided by â¸¨StateTâ¸©.
Monadic operations â¸¨get-path-condâ¸©
and â¸¨refineâ¸© reference and update the path-condition.
Metafunction â¸¨zero?â¸© works similarly to the concrete counterpart,
but also uses the path-condition to prove that some symbolic numbers
are definitely â¸¨0â¸© or non-â¸¨0â¸©.
In case of uncertainty, â¸¨zero?â¸© returns both answers
besides refining the path-condition with the assumption made.
Operator â¸¨'Â¬â¸© represents negation in our language.

In the following example, the symbolic executor recognizes that
result â¸¨3â¸© and division-by-0 error are not feasible:
â„‘â…
Â¦ > (if0 'x (if0 'x 2 3) (/ 5 'x))
â„‘,
Â¦ (set
Â¦    (cons '(/ 5 x) (set '(Â¬ x)))
Â¦    (cons 2 (set 'x)))
â„‘â†

A scaled up symbolic executor can have â¸¨zero?â¸© calling out
to an SMT solver for interesting arithmetics,
and extend the language with symbolic functions
and blame semantics for sound higher-order symbolic
execution~\cite{dvanhorn:TobinHochstadt2012Higherorder,dvanhorn:Nguyen2015Relatively}.

\begin{figure}
\begin{alignat*}{4}
   e âˆˆ &&\mathrel{}   exp â©´ â€¦ âˆ£ &\mathrel{} ğ”¥â¸¨(symâ¸©\ xğ”¥â¸¨)â¸©             &\hspace{3em} [â¦‘\emph{symbolic number}â¦’]
\end{alignat*}
\rfloat{â¸¨symbolic-monad@â¸©}
\begin{lstlisting}
Â¦ (define-monad
Â¦   (ReaderT (FailT (StateT (StateT (NondetT ID))))))
\end{lstlisting}
\figskip\rfloat{â¸¨ev-symbolic@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-symbolic evâ‚€) ev) e)
Â¦   (match e
Â¦     [(sym x) (return x)]
Â¦     [e       ((evâ‚€ ev) e)]))
\end{lstlisting}
\figskip\rfloat{â¸¨Î´-symbolic@â¸©}
\begin{lstlisting}
Â¦ (define (Î´ . ovs)
Â¦   (match ovs
Â¦     ... ; TODO can't put comment in here...
Â¦     [(list '/ vâ‚€ vâ‚)
Â¦      (do z? â† (zero? vâ‚)
Â¦          (cond
Â¦           [z? fail]
Â¦           [(and (number? vâ‚€) (number? vâ‚))
Â¦            (return (/ vâ‚€ vâ‚))]
Â¦           [else
Â¦            (return `(/ ,vâ‚€ ,vâ‚))]))]
Â¦     [(list 'Â¬ 0) 1]
Â¦     ... ; TODO can't put comment in here...
Â¦     ))
Â¦ (define (zero? v)
Â¦   (do Ï† â† get-path-cond
Â¦       (match v
Â¦         [(? number? n) (return (= 0 n))]
Â¦         [v #:when (âˆˆ v Ï†) (return #t)]
Â¦         [v #:when (âˆˆ `(Â¬ ,v) Ï†) (return #f)]
Â¦         [`(Â¬ ,vâ€²) (do a â† (zero? vâ€²)
Â¦                       (return (not a)))]
Â¦         [v (mplus (do (refine v)
Â¦                       (return #t))
Â¦                   (do (refine `(Â¬ ,v))
Â¦                       (return #f)))])))
\end{lstlisting}
\caption{Symbolic Execution Variant}
\label{f:symbolic}
\end{figure}

\subsection{From Symbolic Execution to Verification}

Traditional symbolic executors mainly aim to find bugs
and provide no termination guarantee.
We can apply abstracting units presented in previous sections,
namely base value widening (Section~\ref{s:base}), finite allocation
(Section~\ref{s:closures}), caching and fixing (Sections~\ref{s:cache}
and~\ref{s:fixing-cache}) to turn a symbolic execution into a sound,
path-sensitive program verification.

Operations on symbolic values introduce a new source of infinite configurations
by building up new symbolic values.
We therefore straightforwardly widen a symbolic value to the abstract
number â¸¨'Nâ¸© when it shares an address with a different number.
Figure~\ref{f:symbolic-widen} shows extension to â¸¨Î´â¸© and â¸¨zero?â¸©
in the presence of â¸¨'Nâ¸©.
The different treatments of â¸¨'Nâ¸© and symbolic values
clarifies that abstract values are not symbolic values:
the former stands for a set of multiple values,
whereas the latter stands for an single unknown value.
Tests on abstract number â¸¨'Nâ¸© do not strengthen the path-condition.
It is unsound to accumulate any assumption about â¸¨'Nâ¸©.

\begin{figure}
\rfloat{â¸¨Î´-symbolic@â¸©}
\begin{lstlisting}
Â¦ (define (Î´ . ovs)
Â¦   (match ovs
Â¦     ... ; TODO can't put comment in here...
Â¦     [(list '/ vâ‚€ vâ‚)
Â¦      (do z? â† (zero? vâ‚)
Â¦          (cond
Â¦           [z? fail]
Â¦           [else
Â¦            (match (list vâ‚€ vâ‚)
Â¦             [(list (? number? nâ‚€) (? number? nâ‚))
Â¦              (return (/ nâ‚€ nâ‚))]
Â¦             [(list _ ... 'N _ ...)
Â¦              (return 'N)]
Â¦             [(list vâ‚€ vâ‚)
Â¦              (return `(/ ,vâ‚€ ,vâ‚))])]))]
Â¦     ... ; TODO can't put comment in here...
Â¦     ))
Â¦ (define (zero? v)
Â¦   (do Ï† â† get-path-cond
Â¦       (match v
Â¦         ['N (mplus (return #t) (return #f))]
Â¦         ...)))
\end{lstlisting}
\caption{Symbolic Execution with Abstract Numbers}
\label{f:symbolic-widen}
\end{figure}
