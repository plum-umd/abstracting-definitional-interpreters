\section{Widening the Store}\label{s:widening}

The abstract interpreter we've constructed so far uses a
store-per-program-state abstraction, which while precise is also prohibitively
expensive. A common technique to combat this cost is to use a global
``widenened'' store, which over-approximates all the individual stores in the
current set-up.  Thanks to our monad transformer framework, this change can be
achieved simply by re-ordering of the monad stack, a technique due to Darais
\emph{et al}~\cite{local:darais-oopsla2015}. Whereas before we had:
\begin{alignat*}{1}
  & ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨NondetTâ¸©}â¸¢mplusâ¸£
\\[\monadgobble]& â£â£ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢in-\$â¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢out-\$â¸£\ ğ”¥â¸¨ID))))))â¸©
\end{alignat*}
we instead swap the order of â¸¨StateTâ¸© for the store and â¸¨NondetTâ¸©:
\begin{alignat*}{1}
  & ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨NondetTâ¸©}â¸¢mplusâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢storeâ¸£
\\[\monadgobble]& â£â£ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢in-\$â¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢out-\$â¸£\ ğ”¥â¸¨ID))))))â¸©
\end{alignat*}
we get a store-widened variant of the abstract interpreter. Because â¸¨StateTâ¸©
for the store appears underneath nondeterminism, it will be automatically
widened. We write â¸¨StateT+â¸© to signify that the cell of state supports such
widening. 

% To see the difference, here is an example without store-widening:
% â„‘â…
% Â¦ (let x (+ 1 0)
% Â¦   (let y (if0 x 1 2)
% Â¦     (let z (if0 x 3 4)
% Â¦       (if0 x y z))))
% â„‘,
% Â¦ '((4 . ((x N) (y 2) (z 4)))
% Â¦   (1 . ((x N) (y 1) (z 3)))
% Â¦   (2 . ((x N) (y 2) (z 3)))
% Â¦   (3 . ((x N) (y 1) (z 3)))
% Â¦   (1 . ((x N) (y 1) (z 4)))
% Â¦   (3 . ((x N) (y 2) (z 3)))
% Â¦   (2 . ((x N) (y 2) (z 4)))
% Â¦   (4 . ((x N) (y 1) (z 4))))
% â„‘â†
% and with:
% â„‘â…
% Â¦ (let x (+ 1 0)
% Â¦   (let y (if0 x 1 2)
% Â¦     (let z (if0 x 3 4)
% Â¦       (if0 x y z))))
% â„‘,
% Â¦ '((1 3 2 4) . ((x N) (y 1 2) (z 3 4)))
% â„‘â†
% Notice that before widening, the result is a set of value, store
% pairs.  After widening the result is a pair of a set of values and a
% store.  Importantly, the cache, which bounds the overall run-time of
% the abstract interpreter, is potentially exponential without
% store-widening, but collapses to polynomial after store-widening.
