\section{Widening the Store}\label{s:widening}

The abstract interpreter we've constructed so far uses a
store-per-program-state abstraction, which is precise but prohibitively
expensive. A common technique to combat this cost is to use a global
``widened'' store~\cite{dvanhorn:might-phd,dvanhorn:Shivers:1991:CFA}, which over-approximates each individual store in the
current set-up. This change is achieved easily in the monadic setup by
re-ordering the monad stack, a technique due to \citet{local:darais-oopsla2015}. Whereas before we had â¸¨monad-cache@â¸© we
instead swap the order of â¸¨StateTâ¸© for the store and â¸¨NondetTâ¸©:
\begin{alignat*}{1}
& ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨NondetTâ¸©}â¸¢mplusâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢in-\$â¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢out-\$â¸£\ ğ”¥â¸¨ID))))))â¸©
\end{alignat*}
we get a store-widened variant of the abstract interpreter. Because â¸¨StateTâ¸©
for the store appears underneath nondeterminism, it will be automatically
widened. We write â¸¨StateT+â¸© to signify that the cell of state supports such
widening. 

% To see the difference, here is an example without store-widening:
% â„‘â…
% Â¦ (let x (+ 1 0)
% Â¦   (let y (if0 x 1 2)
% Â¦     (let z (if0 x 3 4)
% Â¦       (if0 x y z))))
% â„‘,
% Â¦ '((4 . ((x N) (y 2) (z 4)))
% Â¦   (1 . ((x N) (y 1) (z 3)))
% Â¦   (2 . ((x N) (y 2) (z 3)))
% Â¦   (3 . ((x N) (y 1) (z 3)))
% Â¦   (1 . ((x N) (y 1) (z 4)))
% Â¦   (3 . ((x N) (y 2) (z 3)))
% Â¦   (2 . ((x N) (y 2) (z 4)))
% Â¦   (4 . ((x N) (y 1) (z 4))))
% â„‘â†
% and with:
% â„‘â…
% Â¦ (let x (+ 1 0)
% Â¦   (let y (if0 x 1 2)
% Â¦     (let z (if0 x 3 4)
% Â¦       (if0 x y z))))
% â„‘,
% Â¦ '((1 3 2 4) . ((x N) (y 1 2) (z 3 4)))
% â„‘â†
% Notice that before widening, the result is a set of value, store
% pairs.  After widening the result is a pair of a set of values and a
% store.  Importantly, the cache, which bounds the overall run-time of
% the abstract interpreter, is potentially exponential without
% store-widening, but collapses to polynomial after store-widening.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{â¸¨precise-Î´@â¸©}
\begin{lstlisting}
Â¦ (define (Î´ o nâ‚€ nâ‚)
Â¦   (match* (o nâ‚€ nâ‚)
Â¦     [('+ (? num?) (? num?)) (return (+ nâ‚€ nâ‚))]
Â¦     [('+ _        _       ) (return 'N)] ... ))
Â¦ (define (zero? v)
Â¦   (match v
Â¦     ['N (mplus (return #t) (return #f))]
Â¦     [_  (return (zero? v))]))
\end{lstlisting}
\figskip\rfloat{â¸¨store-crush@â¸©}
\begin{lstlisting}
Â¦ (define (find a)
Â¦   (do Ïƒ â† get-store
Â¦       (for/monad+ ([v (Ïƒ a)]) (return v))))
Â¦ (define (crush v vs)
Â¦   (if (closure? v)
Â¦       (set-add vs v)
Â¦       (set-add (set-filter closure? vs) 'N)))
Â¦ (define (ext a v)
Â¦   (update-store (Î» (Ïƒ) (if (âˆˆ a Ïƒ)
Â¦                            (Ïƒ a (crush v (Ïƒ a)))
Â¦                            (Ïƒ a (set v))))))
\end{lstlisting}
\captionskip{An Alternative Abstraction for Precise Primitives}
\label{f:pres-delta}
\end{mdframed}
\end{figure} %}-}
