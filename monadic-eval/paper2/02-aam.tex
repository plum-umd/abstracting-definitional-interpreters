\section{From Machines to Compositional Evaluators}

In recent years, there has been considerable effort in the systematic
construction of abstract interpreters for higher-order languages using abstract
machines---first-order transition systems---as a semantic basis.  The so-called
\emph{Abstracting Abstract Machines} (AAM) approach to abstract
interpretation~\cite{dvanhorn:VanHorn2010Abstracting} is a recipe for
transforming a machine semantics into an easily abstractable form. The
transformation includes the following ingredients:
\begin{itemize}
\item Allocating continuations in the store;
\item Allocated variable bindings in the store;
\item Using a store that maps addresses to \emph{sets} of values;
\item Interpreting store updates as a join; and
\item Interpreting store dereference as a non-deterministic choice.
\end{itemize}
These transformations are semantics-preserving due to the original and derived
machines operating in a lock-step correspondence.  After transforming the
semantics in this way, a \emph{computable} abstract interpreter is achieved by:
\begin{itemize}
\item Bounding store allocation to a finite set of addresses; and
\item Widening base values to some abstract domain.
\end{itemize}
After performing these transformations, the soundness and computability of the
resulting abstract interpreter are then self-evident and easily proved.

The AAM approach has been applied to a wide variety of languages and
applications, and given the success of the approach it's natural to wonder what
is essential about its use of low-level machines. It is not at all clear
whether a similar approach is possible with a higher-level formulation of the
semantics, such as a compositional evaluation function, or so-called big-step
semantics.

This paper shows that the essence of the AAM approach can be applied to a
high-level semantic basis.  We show that compositional evaluators written in
monadic style can express similar abstractions to that of AAM, and like AAM,
the design remains systematic.  Moreover, we show that the high-level semantics
offers a number of benefits not available to the machine model.  

\begin{figure} %{-{ f:syntax
\begin{alignat*}{4}
   e âˆˆ &&\mathrel{}   exp â©´ &\mathrel{} ğ”¥â¸¨(vblâ¸©\ xğ”¥â¸¨)â¸©         &\hspace{3em} [â¦‘\emph{variable}â¦’]
\\[\mathgobble]     &&\mathrel{}       âˆ£ &\mathrel{} ğ”¥â¸¨(numâ¸©\ nğ”¥â¸¨)â¸©         &\hspace{3em} [â¦‘\emph{number}â¦’]
\\[\mathgobble]     &&\mathrel{}       âˆ£ &\mathrel{} ğ”¥â¸¨(lamâ¸©\ x\ ğ”¥â¸¨)â¸©       &\hspace{3em} [â¦‘\emph{lambda}â¦’]
\\[\mathgobble]     &&\mathrel{}       âˆ£ &\mathrel{} ğ”¥â¸¨(ifzâ¸©\ e\ e\ eğ”¥â¸¨)â¸©   &\hspace{3em} [â¦‘\emph{conditional}â¦’]
\\[\mathgobble]     &&\mathrel{}       âˆ£ &\mathrel{} ğ”¥â¸¨(op2â¸©\ b\ e\ eğ”¥â¸¨)â¸©   &\hspace{3em} [â¦‘\emph{binary op}â¦’]
\\[\mathgobble]     &&\mathrel{}       âˆ£ &\mathrel{} ğ”¥â¸¨(appâ¸©\ e\ eğ”¥â¸¨)â¸©      &\hspace{3em} [â¦‘\emph{application}â¦’]
\\[\mathgobble]     &&\mathrel{}       âˆ£ &\mathrel{} ğ”¥â¸¨(recâ¸©\ x\ e\ eğ”¥â¸¨)â¸©   &\hspace{3em} [â¦‘\emph{letrec}â¦’]
\\[\mathgobble] x âˆˆ &&\mathrel{}   var â‰” &\mathrel{} â´ğ”¥â¸¨xâ¸©, ğ”¥â¸¨yâ¸©, â€¦âµ        &\hspace{3em} [â¦‘\emph{variable names}â¦’]
%\\[\mathgobble] u âˆˆ &&\mathrel{}  unop â‰” &\mathrel{} â´ğ”¥â¸¨add1â¸©, â€¦âµ           &\hspace{3em} [â¦‘\emph{unary prim}â¦’]
\\[\mathgobble] b âˆˆ &&\mathrel{} binop â‰” &\mathrel{} â´ğ”¥â¸¨+â¸©, ğ”¥â¸¨-â¸©, â€¦âµ        &\hspace{3em} [â¦‘\emph{binary prim}â¦’]
\end{alignat*}
\vspace{-1em}
\caption{Programming Language Syntax}
\label{f:syntax}
\vspace{-1em}
\end{figure} %}-}

There is a rich body of work concerning tools and techniques for
\emph{extensible} interpreters, all of which applies to high-level semantics.
By putting abstract interpretation for higher-order languages on a high-level
semantic basis, we can bring these results to bear on the construction of
extensible abstract interpreters in ways that were not available to the
small-step machine world.
