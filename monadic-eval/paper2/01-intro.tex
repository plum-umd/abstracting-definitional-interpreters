\section{Introduction}

An abstract interpreter is intended to soundly and effectively compute
an over-approximation to its concrete counterpart.  For higher-order
langauges, these concrete interpreters tend to be formulated as
state-machines~\cite{dvanhorn:jagannathan-etal-popl98, }.  There are several reasons
for this choice:
 they operate with simple transfer functions defined over
  similarly simple data structures,
 they make explicit all aspects of the state of a computation,
  and
 computing fixed-points in the set of reachable states is
  straightforward.
%
The essence of the state-machine based approach was distilled by Van
Horn and Might in their ``abstracting abstract machines'' (AAM)
technique, which provides a systematic method for constructing
abstract interpreters from standard abstract machines like the CEK or
Krivine-machines \cite{dvanhorn:VanHorn2010Abstracting}.  Language
designers who would like to build abstract interpreters and program
analysis tools for their language can now, in principle at least,
first build a state-machine interpreter and then turn the crank to
construct the approximating abstract counterpart.

A natural pair of questions that arise from this past work is to wonder
(1) can a systematic abstraction technique similar to AAM  be
carried out for interpreters written, \emph{not} as state-machines,
but instead as high-level definitional interpreters, i.e. recursive,
compositional evaluators? And (2) is such a perspective fruitful?  In
this functional pearl we seek to answer both questions in the
affirmative.

For the first question, we show the AAM recipe can be applied
to definitional interpreters in a straightforward adaptation of the
original method. The primary technical challenge in this new setting
is handling interpreter fixpoints in a way that is both sound and
always terminates---a naive abstraction of fixpoints will be sound but
isn't always terminating, and a naive use of caching for fixpoints
will guarantee termination but is inherently unsound. We address this
technical challenge with a straightforward caching fixpoint-finding
algorithm which is both sound guaranteed to terminate when abstracting
arbitrary definitional interpreters.

For the second question, we claim that the abstract definitional
interpreter perspective is fruitful in two regards.  The first is
unsurprising: high-level abstract interpreters offer the ususal
beneficial properties of their concrete counterparts in terms of being
re-usable and extensible.  In particular, we show that abstract
interpreters can be structured with monad transformers to good effect.
The second regard is more suprising, and we consider its observation
to be the main contribution of this pearl.

Definitional interpreters, as opposed to abstract machines, can leave
aspects of computation implicit, relying on the semantics of the
defin\emph{ing}-language to define the semantics of the
defin\emph{ed}-language, an observation made by Reynolds in his landmark
paper, \emph{Definitional Interpreters for Higher-order Programming
  Languages}~\cite{dvanhorn:reynolds-acm72}.  For example, Reynolds showed it is
possible to write a definitional interpreter such that it defines a
call-by-value language when the metalanguage is call-by-value, and
defines a call-by-name language when the metalanguage is call-by-name.
Inspired by Reynolds, we show that \emph{abstract} definitional interpreters can likewise
inherit properties of the metalanguage.  In particular we construct an
abstract definitional interpreter where there is no explicit
representation of continuations or a call stack.  Instead the
interpreter is written in a straightfoward recursive style, and the
call stack is implicitly handled by the metalangauge.  What emerges
from this construction is a total abstract evaluation function that
soundly approximates all possible concrete executions of a given
program.  But remarkably, since the abstract evaluator relies on the
metalanguage to manage the call stack implicitly, it is easy to
oberserve that it introduces no approximation in the matching of calls
and returns, and therefore implements a ``pushdown'' analysis, all
without the need for any explicit machinery to do so.

\subsection*{Outline}

In the remainder of this pearl, we present an adaptation of the AAM
method to the setting of recursively-defined, compositional evaluation
functions, a.k.a.~definitional interpreters.  We first briefly review
the basic ingredients in the AAM recipe (\S\ref{s:aam}) and then
define our definitional interpreter (\S\ref{s:interp}).  The
interpreter is largely standard, but is written in a monadic and
extensible style, so as to be re-usable for various forms of semantics
we examine.  The AAM technique applies in a basically straightfoward
way by store-allocating bindings and soundly finitizing the heap.  But
when naively run, the interpreter will not always terminate.  To solve
this problem we introduce a caching strategy and a simple fixed-point
computation to ensure the interpreter terminates (\S\ref{s:cache}).
It is at this point that we observe the interpreter we have built
enjoys the ``pushdown'' property \emph{\`a la} Reynolds---it is
inherited from the defining language of our interpreter and requires
no explicit mechanism (\S\ref{s:reynolds}).

Having established the main results, we then explore some variations
in brief vignettes that showcase the flexibility of our definitional
abstract interpreter approach.  First we consider the widely used
technique of so-called ``store-widening,'' which trades precision for
efficeincy by modelling the abstract store globally instead of locally
(\S\ref{s:widening}).  Thanks to our monadic formulation of the
interpreter, this is achieved by a simple re-ordering of the monad
transformer stack.  We also explore some alternative abstractions,
showing that due to the extensible construction, it's easy to
experiment with alternative components for the abstract interpreter.
In particular, we define an alternative interpretation of the primitve
operations that remains completely precise until forced by joins in
the store to introduce approximation (\S\ref{s:alt-abstraction}).  As
another variation, we explore computing a form of symbolic execution
as yet another instance of our interpreter (\S\ref{s:symbolic}).  Lastly, we
show how to incorporate so-called ``abstract garbage collection,'' a
well-known technique for improving the precision of abstract
interpretation by clearing out unreachable store locations, thus
avoiding future joins which cause imprecision (\S\ref{s:gc}).  This
last variation is significant because it demonstrates that even though
we have no explicit representation of the stack, it is possible to
compute analyses that typically require such explicit representations
in order to calculate root sets for garbage collection.

Finally, we place our work in the context of the prior literature on
higher-order abstract interpretation (\S\ref{s:related-work}) and draw
some conclusions (\S\ref{s:conclusion}).



%% In his landmark paper, \emph{Definitional Interpreters for Higher-order
%% Programming Languages}~\cite{dvanhorn:reynolds-acm72}, Reynolds observed that
%% when a programming language is defined by way of an interpreter, it is possible
%% to inherit semantic characteristics of the defining metalanguage. For example,
%% it is possible to define a definitional interpreter which is call-by-value when
%% the metalanguage is call-by-value, and call-by-name when the metalanguage is
%% call-by-name.

%% We expand on Reynolds's observation in the setting of abstract interpreters and
%% discover the following:
%% \begin{itemize}
%% \item Definitional interpreters, written in monadic style, can simultaneously
%%   define a language's semantics as well as safe approximations of those
%%   semantics, \emph{i.e.} abstract interpreters.
%% \item These definitional \emph{abstract} interpreters can inherit
%%   characteristics of the defining language.  In particular, precise
%%   call-and-return matching can be inherited, yielding a pushdown
%%   analysis~\cite{dvanhorn:Earl2010Pushdown,local:vardoulakis-diss12}.
%% \end{itemize}
%% Furthermore, we contribute:
%% \begin{itemize}
%% \item A systematic methodology for designing abstract interpreters via
%%   definitional interpreters; and
%% \item A soundness framework establishing the correctness of abstract
%%   interpreters defined in definitional style.
%% \end{itemize}

%% \paragraph{A Compositional Approach to Program Analysis}
%% There are many approaches to designing program analyzers for programming
%% languages. For \emph{higher-order} programming languages, two popular
%% approaches are to use abstract machines~\cite{dvanhorn:VanHorn2010Abstracting}
%% and constraint systems~\cite{dvanhorn:Neilson:1999}. Other foundations exist
%% for designing program analyzers, but no approach to-date utilizes big-step
%% operational semantics or definitional interpreters for program analysis of
%% higher-order languages. This is unfortunate because big-step semantics and
%% definitional interpreters are more compositional and high-level than state
%% machines or constraint systems. Big-step and denotational approaches exist for
%% first-order programming languages; the gap is in extending these ideas to the
%% higher-order setting.

%% We bridge this gap, providing the first framework for program analysis of
%% higher-order languages which builds upon big-step semantics and their
%% corresponding definitional interpreters, which are compositional by nature. 

%% Our key insights are to design definitional interpreters in monadic,
%% open-recursive style (§~\ref{s:interp}), and to design a
%% novel fixpoint algorithm tailored specifically to the setting of higher-order
%% definitional interpreters (§~\ref{s:cache}). The extensible nature of the
%% interpreter allows us to recover a wide-range of analyses through its
%% instantiation, including widening techniques (§~\ref{s:widening}), precision
%% preserving abstractions (§~\ref{s:alt-abstraction}), and symbolic execution for
%% program verification (§~\ref{s:symbolic}). Our implementation is freely
%% available through a suite of embedded languages in Racket (§~\ref{s:try-it}).
%% Finally, we prove the approach sound w.r.t. a derived big-step collecting and
%% abstract semantics (§~\ref{s:formalism}), where the key insight in the
%% formalism is to model not only standard big-step \emph{evaluation} relations,
%% but also big-step \emph{reachability} relations.

%% \paragraph{Pushdown Precision in Program Analysis}
%% A common problem with traditional approaches to control flow analysis is the
%% inability to properly match a function call with its return in the abstract
%% semantics. This leads to infeasible program (abstract) executions in which a
%% call is made from one point in the program, but control returns to another.
%% The PDCFA analysis of Earl \emph{et al}~\cite{dvanhorn:Earl2010Pushdown} and
%% CFA2 analysis of Vardoulakis and Shivers~\cite{dvanhorn:Vardoulakis2011CFA2}
%% were the first approaches to overcome this limitation in the higher-order
%% setting. In essence, these analyses replaces the traditional finite automata
%% abstractions of programs with pushdown automata, an approach pioneered by Reps
%% \emph{et al}~\cite{dvanhorn:Reps1995Precise} in the first-order setting.

%% We realize a new technique for defining abstract interpreters with pushdown
%% precision, meaning the analysis precisely matches function calls to returns. In
%% the setting of definitional interpreters, this property is inherited from the
%% defining metalanguage and requires no instrumentation to the analysis \emph{at
%% all} (§~\ref{s:reynolds}).

%% A technical difference between small-step and big-step approaches to semantics
%% are that small-step methods must model the execution context of evaluation,
%% whether through evaluation contexts~\cite{local:felleisen-TCS1992} or stack
%% frames~\cite{dvanhorn:Felleisen1987Calculus}. In big-step methods, there is no
%% model for the context; it is implicit in the definition of evaluation rules, or
%% in the case of definitional interpreters, implicit in the call-and-return
%% semantics of the defining programming language. Because a defining programming
%% language is precise in its call/return behavior, so is a definitional abstract
%% interpreter embedded within it.
