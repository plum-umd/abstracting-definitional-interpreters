\section{A Definitional Interpreter}\label{s:interp}

We begin by constructing a definitional interpreter for a small but
representative higher-order, functional language.  As our defining language, we
use an applicative subset of Racket, a dialect of Scheme.\footnote{This choice
is largely immaterial: any functional language would do.} The abstract syntax
of the language is defined in Figure~\ref{f:syntax}; it includes variables,
numbers, unary and binary operations on numbers, conditionals, {\tt letrec}
expressions, functions and applications.

\begin{figure} %{-{
\rfloat{â¸¨ev@â¸©}
\begin{lstlisting}
Â¦ (define ((ev ev) e)
Â¦   (match e
Â¦     [(num n) (return n)]
Â¦     [(vbl x)
Â¦      (do Ï â† ask-env
Â¦          (find (Ï x)))]    
Â¦     [(ifz eâ‚€ eâ‚ eâ‚‚) 
Â¦      (do v  â† (ev eâ‚€)
Â¦          z? â† (zero? v)
Â¦          (ev (if z? eâ‚ eâ‚‚)))]
Â¦     [(op1 o eâ‚€)
Â¦      (do v â† (ev eâ‚€)
Â¦          (Î´ o v))]   
Â¦     [(op2 o eâ‚€ eâ‚)
Â¦      (do vâ‚€ â† (ev eâ‚€)
Â¦          vâ‚ â† (ev eâ‚)
Â¦          (Î´ o vâ‚€ vâ‚))]
Â¦     [(lrc f eâ‚€ eâ‚) 
Â¦      (do Ï  â† ask-env
Â¦          a  â† (alloc f)
Â¦          Ïâ€² â‰” (Ï f a)
Â¦          (ext a (cons eâ‚€ Ïâ€²))
Â¦          (local-env Ïâ€²
Â¦            (ev eâ‚)))]
Â¦     [(lam x eâ‚€)
Â¦      (do Ï â† ask-env
Â¦          (return (cons (lam x eâ‚€) Ï)))]
Â¦     [(app eâ‚€ eâ‚)
Â¦      (do (cons (lam x eâ‚‚) Ï) â† (ev eâ‚€)
Â¦          vâ‚ â† (ev eâ‚)
Â¦          a  â† (alloc x)         
Â¦          (ext a vâ‚)
Â¦          (local-env (Ï x a) 
Â¦            (ev eâ‚‚)))]))
\end{lstlisting}
\caption{The Extensible Definitional Interpreter}
\label{f:interpreter}
\end{figure} %}-}

The interpreter for the language is defined in Figure~\ref{f:interpreter}. At
first glance, it has many conventional aspects:
\begin{itemize}
\item It is compositionally defined by structural recursion on the syntax of
expressions;
\item It represents function values as a closure data structure which pairs the
function body with the evaluation environment;
\item It is structured monadically and uses monad operations to interact with
the environment and store; and
\item It relies on a helper function â¸¨Î´â¸© to interpret primitive operations.
\end{itemize}
There are a few superficial aspects that deserve a quick note:
environments â¸¨Ïâ¸© are finite maps and â¸¨(ÏÂ«\ Â»x)â¸© denotes
Â«Ï(x)Â» while â¸¨(ÏÂ«\ Â»x a)â¸© denotes Â«Ï[xâ†¦a]Â».  The
â¸¨doâ¸©-notation is just shorthand for â¸¨bindâ¸©, as usual:

% LAYOUT
\begin{alignat*}{2}
   ğ”¥â¸¨(do x â†Â«\ Â»e . r)â¸© â‰¡ &\mathrel{} ğ”¥â¸¨(bind e (Î»Â«\ Â»(x) (do . r)))â¸©
\\        ğ”¥â¸¨(do e . r)â¸© â‰¡ &\mathrel{} ğ”¥â¸¨(bind e (Î»Â«\ Â»(_) (do . r)))â¸©
\\ ğ”¥â¸¨(do x â‰”Â«\ Â»e . r)â¸© â‰¡ &\mathrel{} ğ”¥â¸¨(let ((x e)) (do . r))â¸©
\\            ğ”¥â¸¨(do b)â¸© â‰¡ &\mathrel{} ğ”¥â¸¨bâ¸©
\end{alignat*}
Finally, there are two unconventional aspects worth noting.

First, the interpreter is written in an \emph{open recursive style}; the
evaluator does not call itself recursively, instead it takes as an argument a
function â¸¨evâ¸©â€”shadowing the name of the function â¸¨evâ¸© being definedâ€”and â¸¨evâ¸©
(the argument) is called instead of self-recursion.  This is a standard
encoding for recursive functions in a setting without recursive binding.  It is
up to an external function, such as the Y-combinator, to close the recursive
loop.  This open recursive form is crucial for our purposes in that it allows
intercepting recursive calls to perform â€œdeepâ€ instrumentation of the
interpreter.

Second, the code is clearly \emph{incomplete}.  There are a number of free
variables, noted in italics, which must implement the following:
\begin{itemize}
\item The underlying monad of the interpreter: â¸¨returnâ¸© and â¸¨bindâ¸©;
\item An interpretation of primitives: â¸¨Î´â¸© and â¸¨zero?â¸©;
\item Environment operations: â¸¨ask-envâ¸© for retrieving the
environment and â¸¨local-envâ¸© for installing an environment;
\item Store operations: â¸¨extâ¸© for updating the store, and â¸¨findâ¸© for
dereferencing locations; and
\item An operation for â¸¨allocâ¸©ating new store locations.
\end{itemize}
Going forward, we make frequent use of definitions involving free variables,
and we call such a collection of such definitions a \emph{component}. We assume
components can be named (in this case, we've named the component â¸¨ev@â¸©,
indicated by the box in the upper-right corner) and linked together to
eliminate free variables.\footnote{We use Racket
\emph{units}~\cite{local:flatt-pldi98} to model components in our
implementation.}

\begin{figure} %{-{
\rfloat{â¸¨monad@â¸©}
\begin{alignat*}{1}
          & ğ”¥â¸¨(define-monadâ¸©
\\[-0.5em]& â£â£ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨ID))))â¸©
\end{alignat*}
\figskip\rfloat{â¸¨Î´@â¸©}
\begin{lstlisting}
Â¦ (define (Î´ . ovs)
Â¦   (match ovs
Â¦     [(list 'add1 n)  (return (add1 n))]
Â¦     [(list 'sub1 n)  (return (sub1 n))]
Â¦     [(list '- n)     (return (- n))]
Â¦     [(list '+ nâ‚€ nâ‚) (return (+ nâ‚€ nâ‚))]
Â¦     [(list '- nâ‚€ nâ‚) (return (- nâ‚€ nâ‚))]
Â¦     [(list '* nâ‚€ nâ‚) (return (* nâ‚€ nâ‚))]
Â¦     [(list 'quotient nâ‚€ nâ‚)
Â¦      (if (= 0 nâ‚)
Â¦          fail
Â¦          (return (quotient nâ‚€ nâ‚)))]))
Â¦ (define (zero? v)
Â¦   (return (= 0 v)))
\end{lstlisting}
\figskip\rfloat{â¸¨store@â¸©}
\begin{lstlisting}
Â¦ (define (find a)
Â¦   (do Ïƒ â† get-store
Â¦       (return (Ïƒ a))))
Â¦ (define (ext a v) 
Â¦   (update-store (Î» (Ïƒ) (Ïƒ a v))))
\end{lstlisting}
\figskip\rfloat{â¸¨alloc@â¸©}
\begin{lstlisting}
Â¦ (define (alloc x)
Â¦   (do Ïƒ â† get-store
Â¦       (return (size Ïƒ))))
\end{lstlisting}
\caption{Components for Definitional Interpreters}
\label{f:concrete-components}
\end{figure} %}-}

\subsection{Instantiating the Interpreter}

Next we examine a set of components which complete the definitional
interpreter, defined in Figure~\ref{f:concrete-components}. The first component
is â¸¨monad@â¸©, which uses our â¸¨define-monadâ¸© macro to generate a set of bindings
based on a monad transformer stack.  For this interpreter, we use a failure
monad to model divide-by-zero errors, a state monad to model the store, and a
reader monad to model the environment.  The â¸¨define-monadâ¸© form generates
bindings for â¸¨returnâ¸©, â¸¨bindâ¸©, â¸¨ask-envâ¸©, â¸¨local-envâ¸©, â¸¨get-storeâ¸© and
â¸¨update-storeâ¸©, and their definitions are
standard~\cite{dvanhorn:Liang1995Monad}. 

We also add the â¸¨mrunâ¸© operation for running monadic computations, starting
with the empty environment and store â¸¨âˆ…â¸©:
\begin{lstlisting}
Â¦ (define (mrun m)
Â¦   (run-StateT âˆ… (run-ReaderT âˆ… m)))
\end{lstlisting}
While the â¸¨define-monadâ¸© form is hiding some details, this component could have
equivalently been written out explicitly. For example, â¸¨returnâ¸© and â¸¨bindâ¸© can
be defined as:
\begin{lstlisting}
Â¦ (define (((return a) r) s) (cons a s))
Â¦ (define (((bind ma f) r) s)
Â¦   (match ((ma r) s)
Â¦     [(cons a sâ€²) (((f a) r) sâ€²)]
Â¦     ['failure 'failure]))
\end{lstlisting}
The remaining operations are similarly straightforward.  So far our use of
monad transformers can be seen as a mere convenience, but the monad abstraction
will become essential for deriving new analyses later on.

The â¸¨Î´@â¸© component defines the interpretation of primitives, which is given in
terms of the underlying monad.  Finally the â¸¨alloc@â¸© component provides a
definition of â¸¨allocâ¸©, which fetches the store and uses its size to return a
fresh address (assuming the invariant Â«ğ”¥â¸¨(âˆˆÂ«\ Â»a Ïƒ)â¸© â‡” ğ”¥â¸¨aâ¸© < ğ”¥â¸¨(size Ïƒ)â¸©Â».
The â¸¨store@â¸© component defines â¸¨findâ¸© and â¸¨extâ¸© for finding and extending the
store in terms of the monadic operations.

The only remaing pieces of the puzzle are a fixed-point combinator, which is
straightforward to define:
\begin{lstlisting}
Â¦ (define ((fix f) x) ((f (fix f)) x))
\end{lstlisting}
and the main entry-point for the interpreter:
\begin{lstlisting}
Â¦ (define (eval e) (mrun ((fix ev) e)))
\end{lstlisting}
By taking advantage of Racket's languages-as-libraries
features~\cite{dvanhorn:TobinHochstadt2011Languages}, we construct REPLs for
interacting with this interpreter.  Here are a few examples, which make use of
a concrete syntax for more succinctly writing expressions. The identity
function evaluates to an answer consisting of a closure over the empty
environment together with the empty store:
â„‘â…
Â¦ > (Î» (x) x)
â„‘,
Â¦ '(((Î» (x) x) . ()) . ())
â„‘â†
Here's an example showing a non-empty environment and store:
â„‘â…
Â¦ > ((Î» (x) (Î» (y) x)) 4)
â„‘,
Â¦ '(((Î» (y) x) . ((x . 0))) . ((0 . 4)))
â„‘â†
Primitive operations work as expected:
â„‘â…
Â¦ > (* (+ 3 4) 9)
â„‘,
Â¦ '(63 . ())
â„‘â†
And divide-by-zero errors result in failures:
â„‘â…
Â¦ > (quotient 5 (- 3 3))
â„‘,
Â¦ '(failure . ())
â„‘â†
Because our monad stack places â¸¨FailTâ¸© above â¸¨StateTâ¸©, the answer includes the
(empty) store at the point of the error. Had we changed â¸¨monad@â¸© to use:
\begin{alignat*}{1}
          & ğ”¥â¸¨(define-monadâ¸©
\\[-0.5em]& â£â£ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨IDâ¸©))))
\end{alignat*}
failures would not include the store:
â„‘â…
Â¦ > (quotient 5 (- 3 3))
â„‘,
Â¦ 'failure
â„‘â†
At this point we've defined a simple definitional interpreter, although the
extensible components involvedâ€”monadic operations and open recursionâ€”will allow
us to instantiate the same interpreter to achieve a wide range of useful
abstract interpretations.

\subsection{Collecting Variations}\label{s:collecting}

The formal development of abstract interpretation often starts from a so-called
``non-standard collecting semantics.''  A common form of collecting semantics
is a trace semantics, which collects streams of states the interpreter reaches.
Figure~\ref{f:trace} shows the monad stack for a tracing interpreter and a
``mix-in'' for the evaluator.  The monad stack adds â¸¨WriterTâ¸© using â¸¨Listâ¸©,
which provides a new operation â¸¨tellâ¸© for writing items to the stream of
reached states.  The â¸¨ev-traceâ¸© function is a wrapper around an underlying
â¸¨evâ‚€â¸© unfixed evaluator, and interposes itself between each recursive call by
â¸¨tellâ¸©ing the current state of the evaluator, that is the current expression,
environment, and store.  The top-level evaluation function is then:
\begin{lstlisting}
Â¦ (define (eval e) 
Â¦   (mrun ((fix (ev-tell ev)) e)))
\end{lstlisting}

\begin{figure} %{-{
\rfloat{â¸¨trace-monad@â¸©}
\begin{alignat*}{1}
          & ğ”¥â¸¨(define-monadâ¸©
\\[-0.5em]& â£â£ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨WriterT Listâ¸©}â¸¢tracesâ¸£\ ğ”¥â¸¨ID)))))â¸©
\end{alignat*}
\figskip\rfloat{â¸¨ev-tell@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-tell evâ‚€) ev) e)
Â¦   (do Ï â† ask-env
Â¦       Ïƒ â† get-store
Â¦       (tell (list e Ï Ïƒ))
Â¦       ((evâ‚€ ev) e)))
\end{lstlisting}
\caption{Trace Collecting Semantics}
\label{f:trace}
\end{figure} %}-}

Now when an expression is evaluated, we get the resulting answer and a list of
all the states seen by the evaluator, in the order in which they were seen. For
example:
â„‘â…
Â¦ > (* (+ 3 4) 9)
â„‘,
Â¦ '((63 . ())
Â¦   ((* (+ 3 4) 9)()())
Â¦   ((+ 3 4) () ())
Â¦   (3 () ())
Â¦   (4 () ())
Â¦   (9 () ()))
â„‘â†
% â„‘â…
% Â¦ > ((Î» (x) (Î» (y) x)) 4)
% â„‘,
% Â¦ '((((Î» (y) x) . ((x . 0))) . ((0 . 4)))
% Â¦   (((Î» (x) (Î» (y) x)) 4) () ())
% Â¦   ((Î» (x) (Î» (y) x)) () ())
% Â¦   (4 () ())
% Â¦   ((Î» (y) x) ((x . 0)) ((0 . 4))))
% â„‘â†
Were we to swap â¸¨Listâ¸© with â¸¨Setâ¸© in the monad stack, we would obtain a
\emph{reachable} state semantics, another common form of collecting semantics,
that loses the order and repetition of states.

As another collecting semantics variant, we show how to collect the \emph{dead
code} in a program.  Here we use a monad stack that has an additional state
component (with operations named â¸¨put-deadâ¸© and â¸¨get-deadâ¸©) which stores the
set of dead expressions.  Initially this will contain all of the subexpressions
of the program.  As the interpreter recurs through expressions it will remove
them from the dead set.

Figure~\ref{f:dead} defines the monad stack for the dead code collecting
semantics and the â¸¨ev-dead@â¸© component, another mix-in for an â¸¨evâ‚€â¸© evaluator
to remove the given subexpression before recurring.  Since computing the dead
code requires an outer wrapper that sets the initial set of dead code to be all
of the subexpressions in the program, we define â¸¨eval-dead@â¸© which consumes a
\emph{closed evaluator}, i.e. something of the form â¸¨(fix ev)â¸©.

Putting these pieces together, the dead code collecting semantics is defined:
\begin{lstlisting}
Â¦ (define (eval e)
Â¦   (mrun ((eval-dead (fix (ev-dead ev))) e)))
\end{lstlisting}
Running a program with the dead code interpreter produces an answer and the set
of expressions that were not evaluated during the running of a program:
â„‘â…
Â¦ > (if0 0 1 2)
â„‘,
Â¦ (cons '(1 . ()) (set 2))
â„‘;
Â¦ > (* (+ 3 4) 9)
â„‘,
Â¦ (cons '(63 . ()) (set))
â„‘;
Â¦ > (Î» (x) x)
â„‘,
Â¦ (cons '(((Î» (x) x) . ()) . ()) (set 'x))
â„‘;
Â¦ > (if0 (quotient 1 0) 2 3)]
â„‘,
Â¦ (cons '(failure . ()) (set 3 2))
â„‘â†

\begin{figure} %{-{
\rfloat{â¸¨dead-monad@â¸©}
\begin{alignat*}{1}
          & ğ”¥â¸¨(define-monadâ¸©
\\[-0.5em]& â£â£ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨StateTâ¸©}â¸¢deadâ¸£\ ğ”¥â¸¨(â¸©\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨ID)))))â¸©
\end{alignat*}
\figskip\rfloat{â¸¨ev-dead@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-dead evâ‚€) ev) e)
Â¦   (do Î¸  â† get-dead       
Â¦       (put-dead (set-remove Î¸ e))
Â¦       ((evâ‚€ ev) e)))
\end{lstlisting}
\figskip\rfloat{â¸¨eval-dead@â¸©}
\begin{lstlisting}
Â¦ (define ((eval-dead eval) eâ‚€)
Â¦   (do (put-dead (subexps eâ‚€))
Â¦       (eval eâ‚€)))
\end{lstlisting}
\caption{Dead Code Collecting Semantics}
\label{f:dead}
\end{figure} %}-}

Our setup makes it easy not only to express the concrete interpreter, but also
different forms of collecting semantics. Let us now start to look at
abstractions.

\subsection{Abstracting Base Values}\label{s:base}

One of the things an abstract interpreter must do in order to become decidable
is to have some form of abstraction for the base types of the language.  A very
simple approach is to use a finite-element abstract domain.  We can do this for
our sole base type of numbers by introducing a new kind of number, written
â¸¨'Nâ¸©, which is an abstract value that stands for all numbers.  Abstract values
will be introduced by alternative interpretation of the primitive operations,
given in Figure~\ref{f:abs-delta}, which simply produces â¸¨'Nâ¸© in all cases.
Some care must be taken in the interpretation of â¸¨'quotientâ¸© since if the
denominator is an abstract value, the result must include a failure since â¸¨0â¸©
is in the set of values abstracted by â¸¨'Nâ¸©.  This means that dividing a number
by an abstract value must produce \emph{two answers}: â¸¨'Nâ¸© and â¸¨'failureâ¸©.
This is done by adding non-determinism to the monad stack,

\begin{lstlisting}
Â¦ (ReaderT (FailT (StateT (NondetT ID))))
\end{lstlisting}
which provides a â¸¨mplusâ¸© operation for combining multiple answers.
Non-determinism is also used in the implementation of â¸¨zero?â¸©, which returns
both true and false on â¸¨'Nâ¸©.

\begin{figure} %{-{
\rfloat{â¸¨Î´^@â¸©}
\begin{lstlisting}
Â¦ (define (Î´ . ovs)
Â¦   (match ovs
Â¦     [(list 'add1 n)  (return 'N)]
Â¦     [(list 'sub1 n)  (return 'N)]
Â¦     [(list '+ nâ‚€ nâ‚) (return 'N)]
Â¦     [(list '- nâ‚€ nâ‚) (return 'N)]
Â¦     [(list '* nâ‚€ nâ‚) (return 'N)]
Â¦     [(list 'quotient nâ‚€ (? number? nâ‚))
Â¦      (if (= 0 nâ‚) fail (return 'N))]
Â¦     [(list 'quotient nâ‚€ nâ‚)
Â¦      (mplus (return 'N) fail)]))
Â¦ (define (zero? v)
Â¦   (match v
Â¦     ['N (mplus (return #t) (return #f))]
Â¦     [_  (return (= 0 v))]))
\end{lstlisting}
\caption{Abstracting Primitive Operations}
\label{f:abs-delta}
\end{figure} %}-}

By linking together the abstract variant of â¸¨Î´â¸© and the monad stack with
non-determinism, we can obtain an evaluator that produces a set of results:
â„‘â…
Â¦ > (* (+ 3 4) 9)
â„‘,
Â¦ '((N . ()))
â„‘;
Â¦ > (quotient 5 (add1 2))
â„‘,
Â¦ '((failure . ()) (N . ()))
â„‘;
Â¦ > (if0 (add1 0) 3 4)
â„‘,
Â¦ '((3 . ()) (4 . ()))
â„‘â†

If we were to link together the abstract variant of â¸¨Î´â¸© with the \emph{tracing}
monad stack with non-determinism added in,
\begin{lstlisting}
Â¦ (ReaderT (FailT (StateT 
Â¦   (WriterT List (NondetT ID)))))
\end{lstlisting}
we would get an evaluator that produces sets of traces:
â„‘â…
Â¦ > (if0 (add1 0) 3 4)
â„‘,
Â¦ (set
Â¦  '((3 . ())
Â¦    ((if0 (add1 0) 3 4) () ())
Â¦    ((add1 0) () ())
Â¦    (0 () ())
Â¦    (3 () ()))
Â¦  '((4 . ())
Â¦    ((if0 (add1 0) 3 4) () ())
Â¦    ((add1 0) () ())
Â¦    (0 () ())
Â¦    (4 () ())))
â„‘â†

It should be clear that the interepreter will only ever see a finite set of
numbers (including â¸¨'Nâ¸©), but it's definitly not true that the interpreter
halts on all inputs.  Firstly, it's still possible to generate an infinite
number of closures.  Secondly, there's no way for the interpreter to detect
when it sees a loop.  To make a terminating abstract interpreter requires
tackling both.  Let's look next at abstracting closures.
