\section{Garbage Collection}\label{s:gc}

%% Nick:
%% - The figure shows the pdcfa GC monad instance and `mrun'.
%%   `ev-collect' and `ev-roots' work for concrete or abstract.
%% - `ev-cache-gc' and `fix-cache-gc' are small extensions to the caching
%%   algorithm to hold on to Ïˆ (to make sure the search is complete in wake of
%%   AGC). These can be abbreviated with ellipses (as in Î´ for symbolic
%%   execution)--the only changes are in lines that refer to Ïˆ.

\begin{figure} %{-{
\rfloat{â¸¨monad-pdcfa-gc@â¸©}
\begin{flalign*}
& ğ”¥â¸¨(define-monad (â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢rootsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨NondetTâ¸©}â¸¢mplusâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢in-\$â¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢out-\$â¸£\ ğ”¥â¸¨ID))))))))â¸© &
\end{flalign*}
\figskip\rfloat{â¸¨mrun-pdcfa-gc@â¸©}
% Nick:
% The only extension to `mrun' is the last ReaderT for Ïˆ, so I thought
% collapsing the old components to two-per-line was reasonable. The
% other version is just below.
\begin{lstlisting}
Â¦ (define (mrun m)
Â¦   (run-StateT+ âˆ… (run-ReaderT âˆ…   ; out-Â¢â‚€, in-Â¢â‚€
Â¦   (run-StateT  âˆ… (run-ReaderT âˆ…   ; Ïƒâ‚€, Ïâ‚€
Â¦   (run-ReaderT (set) m))))))      ; Ïˆâ‚€
\end{lstlisting}
%% \begin{lstlisting}
%% Â¦ (define (mrun m)
%% Â¦   (run-StateT+ âˆ…     ; out-Â¢â‚€
%% Â¦   (run-ReaderT âˆ…     ; in-Â¢â‚€
%% Â¦   (run-StateT  âˆ…     ; Ïƒâ‚€
%% Â¦   (run-ReaderT âˆ…     ; Ïâ‚€
%% Â¦   (run-ReaderT (set) ; Ïˆâ‚€
%% Â¦                m))))))
%% \end{lstlisting}
\captionskip{Monad Instance with Root Address Set}
\label{f:gc-monad}
\end{figure} %}-}

\begin{figure} %{-{
\begin{lstlisting}
Â¦ (define ((gc Î±s) Ïƒ)
Â¦   (restrict Ïƒ (reachable Î±s Ïƒ)))
Â¦ (define (reachable Î±s s)
Â¦   (define (R to-see seen)
Â¦     (match to-see
Â¦       [(set) seen]
Â¦       [(set Î± Î±s ...)
Â¦        (define sÎ± (s Î±))
Â¦        (define Î±s* (if (set? sÎ±)
Â¦                        (for/fold ([Î±s* (set)])
Â¦                                  ([v (in-set sÎ±)])
Â¦                          (set-union Î±s* (roots-v v)))
Â¦                        (roots-v sÎ±)))
Â¦        (R (set-subtract (set-union Î±s* Î±s) seen)
Â¦           (set-add seen Î±))]))
Â¦   (R Î±s (set)))
Â¦ (define (roots e Ï)
Â¦   (for/set ([x (in-set (fv e))])
Â¦     (Ï x)))
Â¦ (define (roots-v v)
Â¦   (match v
Â¦     [(cons l Ï) (roots l Ï)]
Â¦     [_ (set)]))
\end{lstlisting}
\captionskip{Helper Functions for Garbage Collection}
\label{f:gc-help}
\end{figure} %}-}

\begin{figure} %{-{
\rfloat{â¸¨ev-collect@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-collect ev0) ev) e)
Â¦   (do Ïˆ â† ask-roots
Â¦       v â† ((ev0 ev) e)
Â¦       (update-store (gc (set-union Ïˆ (roots-v v))))
Â¦       (return v)))
\end{lstlisting}
\figskip\rfloat{â¸¨ev-roots@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-roots evâ‚€) ev) e)
Â¦   (match e
Â¦     [(ifz eâ‚€ eâ‚ eâ‚‚) (do Ïˆ  â† ask-roots
Â¦                         Ï  â† ask-env
Â¦                         Ïˆâ€² â‰” (set-union Ïˆ (roots eâ‚ Ï) (roots eâ‚‚ Ï))
Â¦                         v  â† (local-roots Ïˆâ€² (ev eâ‚€))
Â¦                         b  â† (truish? v)
Â¦                         (ev (if b eâ‚ eâ‚‚)))]
Â¦     [(op2 o eâ‚€ eâ‚)  (do Ïˆ  â† ask-roots
Â¦                         Ï  â† ask-env
Â¦                         vâ‚€ â† (local-roots (set-union Ïˆ (roots eâ‚ Ï)) (ev eâ‚€))
Â¦                         vâ‚ â† (local-roots (set-union Ïˆ (roots-v vâ‚€)) (ev eâ‚))
Â¦                         (Î´ o vâ‚€ vâ‚))]
Â¦     [(app eâ‚€ eâ‚)    (do Ï  â† ask-env
Â¦                         Ïˆ  â† ask-roots
Â¦                         vâ‚€ â† (local-roots (set-union Ïˆ (roots eâ‚ Ï)) (ev eâ‚€))
Â¦                         vâ‚ â† (local-roots (set-union Ïˆ (roots-v vâ‚€)) (ev eâ‚))
Â¦                         (cons (lam x eâ‚‚) Ïâ€²) â‰” vâ‚€
Â¦                         a  â† (alloc x)
Â¦                         (ext a vâ‚)
Â¦                         (local-env (Ïâ€² x a) (ev eâ‚‚)))]
Â¦     [_ ((evâ‚€ ev) e)]))
\end{lstlisting}
\captionskip{Address Collection and Propagation}
\label{f:gc-collect-roots}
\end{figure} %}-}

\begin{figure} %{-{
\figskip\rfloat{â¸¨ev-cache-gc@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-cache evâ‚€) ev) e)
Â¦   (do Ï   â† ask-env  Ïƒ â† get-store  Ïˆ â† ask-roots
Â¦       Ï‚   â‰” (list e Ï Ïƒ Ïˆ)
Â¦       Â¢â¸¢outâ¸£ â† get-cache-out
Â¦       (if (âˆˆ Ï‚ Â¢â¸¢outâ¸£)
Â¦           (for/monad+ ([vÃ—Ïƒ (Â¢â¸¢outâ¸£ Ï‚)])
Â¦             (do (put-store (cdr vÃ—Ïƒ))
Â¦                 (return (car vÃ—Ïƒ))))
Â¦           (do Â¢â¸¢inâ¸£    â† ask-cache-in
Â¦               vÃ—Ïƒâ‚€  â‰” (if (âˆˆ Ï‚ Â¢â¸¢inâ¸£) (Â¢â¸¢inâ¸£ Ï‚) âˆ…)
Â¦               (put-cache-out (Â¢â¸¢outâ¸£ Ï‚ vÃ—Ïƒâ‚€))
Â¦               v     â† ((evâ‚€ ev) e)
Â¦               Ïƒâ€²    â† get-store
Â¦               vÃ—Ïƒâ€²  â‰” (cons v Ïƒâ€²)
Â¦               (update-cache-out (Î» (Â¢â¸¢outâ¸£) (Â¢â¸¢outâ¸£ Ï‚ (set-add (Â¢â¸¢outâ¸£ Ï‚) vÃ—Ïƒâ€²))))
Â¦               (return v)))))
\end{lstlisting}
\figskip\rfloat{â¸¨fix-cache-gc@â¸©}
\begin{lstlisting}
Â¦ (define ((fix-cache eval) e)  
Â¦   (do Ï â† ask-env  Ïƒ â† get-store  Ïˆ â† ask-roots
Â¦       Ï‚ â‰” (list e Ï Ïƒ Ïˆ)
Â¦       Â¢âº â† (mlfp (Î» (Â¢) (do (put-cache-out âˆ…)
Â¦                             (put-store Ïƒ)
Â¦                             (local-cache-in Â¢ (eval e))
Â¦                             get-cache-out)))
Â¦       (for/monad+ ([vÃ—Ïƒ (Â¢âº Ï‚)])
Â¦         (do (put-store (cdr vÃ—Ïƒ))
Â¦             (return (car vÃ—Ïƒ))))))
\end{lstlisting}
\figskip\rfloat{â¸¨eval-cache-gc@â¸©}
\begin{lstlisting}
Â¦ (define (eval e)
Â¦   (mrun ((fix-cache (fix (ev-cache (ev-collect (ev-roots ev))))) e)))
\end{lstlisting}
\captionskip{Co-inductive Caching with Garbage Collection}
\label{f:gc-components}
\end{figure} %}-}

