\section{Garbage Collection}\label{s:gc}


As a denouement to our series of examples, each giving a bit more
icing on the cake, we show how to incorporate garbage collection into
our definitional abstract interpreter.

This example, like store-widening, is the rational re-creation of a
well-known technique: abstract garbage
collection~\cite{dvanhorn:Might:2006:GammaCFA} mimics the process of
reclaiming unreachable heap addresses as done in garbage-collecting
concrete interpreters.  While garbage collection in the concrete can
largely be considered an implementation detail that doesn't effect the
results of computation (modulo pragmatic issues of memory
consumption), in the abstract semantics, garbage collection can have a
significant positive effect on the precision of analysis results.
This is because store locations mediate joins, and therefore points of
imprecision, in the abstract semantics.  If an address can be
cleared-out and recycled, this represents the avoidance of a join that
would be encountered in a non-garbage-collecting abstract interpreter.

In the finite-state-machine model, abstract garbage collection is
fairly straightforward and closely follows concrete
formulations~\cite{dvanhorn:Might:2006:GammaCFA,dvanhorn:VanHorn2010Abstracting}.
However, incorporating both pushdown control flow and abstract
garbage collection has proved rather involved and required new
techniques~\cite{dvanhorn:Earl2012Introspective,dvanhorn:Johnson2014Pushdown}.

\begin{figure} %{-{
\begin{mdframed}
\rfloat{â¸¨monad-pdcfa-gc@â¸©}
\begin{flalign*}
& ğ”¥â¸¨(define-monad (â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢rootsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢envâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨FailTâ¸©}â¸¢errorsâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateTâ¸©}â¸¢storeâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨NondetTâ¸©}â¸¢mplusâ¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨ReaderTâ¸©}â¸¢in-\$â¸£\ ğ”¥â¸¨(â¸©\!\up{ğ”¥â¸¨StateT+â¸©}â¸¢out-\$â¸£\ ğ”¥â¸¨ID))))))))â¸© &
\end{flalign*}
\figskip\rfloat{â¸¨mrun-pdcfa-gc@â¸©}
% Nick:
% The only extension to `mrun' is the last ReaderT for Ïˆ, so I thought
% collapsing the old components to two-per-line was reasonable. The
% other version is just below.
\begin{lstlisting}
Â¦ (define (mrun m)
Â¦   (run-StateT+ âˆ… (run-ReaderT âˆ…   ; out-Â¢â‚€, in-Â¢â‚€
Â¦   (run-StateT  âˆ… (run-ReaderT âˆ…   ; Ïƒâ‚€, Ïâ‚€
Â¦   (run-ReaderT (set) m))))))      ; Ïˆâ‚€
\end{lstlisting}
%% \begin{lstlisting}
%% Â¦ (define (mrun m)
%% Â¦   (run-StateT+ âˆ…     ; out-Â¢â‚€
%% Â¦   (run-ReaderT âˆ…     ; in-Â¢â‚€
%% Â¦   (run-StateT  âˆ…     ; Ïƒâ‚€
%% Â¦   (run-ReaderT âˆ…     ; Ïâ‚€
%% Â¦   (run-ReaderT (set) ; Ïˆâ‚€
%% Â¦                m))))))
%% \end{lstlisting}
\captionskip{Monad Instance with Root Address Set}
\label{f:gc-monad}
\end{mdframed}
\end{figure} %}-}

The key difficulty for pushdown machine models, which essentially use
abstract models that are pushdown automata, is that the usual approach
to garbage collection is to crawl the call stack to compute the root
set of reachable addresses~\cite{dvanhorn:Morrisett1995Abstract}.
Traversing the stack, however, is not something that can be expressed
by a pushdown automata.
%
This difficulty is somewhat exacerbated by the definitional
interpreter approach in that there isn't even a stack to traverse!
Nevertheless, as we demonstrate, this challenge can be overcome to
obtain a pushdown, garbage-collecting abstract interpreter.
%
Doing so shows that the definitional abstract interpreter approach
also scales to handle so-called \emph{introspective} pushdown analysis
that require some level of introspection on the
stack~\cite{dvanhorn:Earl2012Introspective,dvanhorn:Johnson2014Pushdown}.

Solving the abstract garbage collection problem for a definitional
abstract interpreter boils down to answer the following question: how
can we track root addresses that are live on the call stack when the
call stack is implicitly defined by the metalanguage?  The answer is
fairly simple: we extend the monad with a set of root addresses.  When
evaluating compound expressions, we calculate the appropriate root
sets for the context.  In essence, we render explicit only the
addresses of the calling context, while still relying on the
metalanguage to implicitly take care of the rest as before.

Figure~\ref{f:gc-monad} defines the appropriate monad instance.  All
that has changed is there is an added reader component, which will be
used to model the context's current root set.
%
The use of this added component necessitates a change to the caching
and fixpoint calculation, namely we must include the root sets as part
of the configuration.  Compared with the â¸¨ev-cache@â¸© component of
Section~\ref{s:cache}, we make a simple adjustment to the first few
lines to cache the root set along with the rest of the configuration:
\begin{lstlisting}
Â¦ (define (((ev-cache evâ‚€) ev) e)
Â¦   (do Ï   â† ask-env  Ïƒ â† get-store  Ïˆ â† ask-roots
Â¦       Ï‚   â‰” (list e Ï Ïƒ Ïˆ)
Â¦       ...))
\end{lstlisting}
Similarly, for â¸¨fix-cache@â¸©:
\begin{lstlisting}
Â¦ (define ((fix-cache eval) e)  
Â¦   (do Ï â† ask-env  Ïƒ â† get-store  Ïˆ â† ask-roots
Â¦       Ï‚ â‰” (list e Ï Ïƒ Ïˆ)
Â¦       ...))
\end{lstlisting}

We can now write a â¸¨ev-collect@â¸© component that performs the garbage
collection: it asks for the current roots in the context, evaluates an
expression to a value, then updates the store after garbage collecting
all addresses not reachable from the root set of the context and the
roots in the produced value:
\begin{lstlisting}
Â¦ (define (((ev-collect ev0) ev) e)
Â¦   (do Ïˆ â† ask-roots
Â¦       v â† ((ev0 ev) e)
Â¦       (update-store (gc (set-union Ïˆ (roots-v v))))
Â¦       (return v)))
\end{lstlisting}
Here, â¸¨gcâ¸© and â¸¨roots-vâ¸© are (omitted) helper functions that perform
garbage collection and calculate the set of root addresses in a value,
respectively.

All that remains is to define a component that propagates root sets
appropriately from compound expressions to their constituents.
Figure~\ref{f:gc-collect-roots} gives the â¸¨ev-roots@â¸© component, which
does exactly this.
%
Finally, the pieces are stitched together with the following to obtain
a pushdown, garbage-collecting definitional abstract interpreter:
\begin{lstlisting}
Â¦ (define (eval e)
Â¦   (mrun ((fix-cache (fix (ev-cache (ev-collect (ev-roots ev))))) e)))
\end{lstlisting}


\begin{figure} %{-{
\begin{mdframed}
\figskip\rfloat{â¸¨ev-roots@â¸©}
\begin{lstlisting}
Â¦ (define (((ev-roots evâ‚€) ev) e)
Â¦   (match e
Â¦     [(ifz eâ‚€ eâ‚ eâ‚‚) (do Ïˆ  â† ask-roots
Â¦                         Ï  â† ask-env
Â¦                         Ïˆâ€² â‰” (set-union Ïˆ (roots eâ‚ Ï) (roots eâ‚‚ Ï))
Â¦                         v  â† (local-roots Ïˆâ€² (ev eâ‚€))
Â¦                         b  â† (truish? v)
Â¦                         (ev (if b eâ‚ eâ‚‚)))]
Â¦     [(op2 o eâ‚€ eâ‚)  (do Ïˆ  â† ask-roots
Â¦                         Ï  â† ask-env
Â¦                         vâ‚€ â† (local-roots (set-union Ïˆ (roots eâ‚ Ï)) (ev eâ‚€))
Â¦                         vâ‚ â† (local-roots (set-union Ïˆ (roots-v vâ‚€)) (ev eâ‚))
Â¦                         (Î´ o vâ‚€ vâ‚))]
Â¦     [(app eâ‚€ eâ‚)    (do Ï  â† ask-env
Â¦                         Ïˆ  â† ask-roots
Â¦                         vâ‚€ â† (local-roots (set-union Ïˆ (roots eâ‚ Ï)) (ev eâ‚€))
Â¦                         vâ‚ â† (local-roots (set-union Ïˆ (roots-v vâ‚€)) (ev eâ‚))
Â¦                         (cons (lam x eâ‚‚) Ïâ€²) â‰” vâ‚€
Â¦                         a  â† (alloc x)
Â¦                         (ext a vâ‚)
Â¦                         (local-env (Ïâ€² x a) (ev eâ‚‚)))]
Â¦     [_ ((evâ‚€ ev) e)]))
\end{lstlisting}
\captionskip{Address Collection and Propagation}
\label{f:gc-collect-roots}
\end{mdframed}
\end{figure} %}-}




%% Nick:
%% - The figure shows the pdcfa GC monad instance and `mrun'.
%%   `ev-collect' and `ev-roots' work for concrete or abstract.
%% - `ev-cache-gc' and `fix-cache-gc' are small extensions to the caching
%%   algorithm to hold on to Ïˆ (to make sure the search is complete in wake of
%%   AGC). These can be abbreviated with ellipses (as in Î´ for symbolic
%%   execution)--the only changes are in lines that refer to Ïˆ.


%% \begin{figure} %{-{
%% \begin{lstlisting}
%% Â¦ (define ((gc Î±s) Ïƒ)
%% Â¦   (restrict Ïƒ (reachable Î±s Ïƒ)))
%% Â¦ (define (reachable Î±s s)
%% Â¦   (define (R to-see seen)
%% Â¦     (match to-see
%% Â¦       [(set) seen]
%% Â¦       [(set Î± Î±s ...)
%% Â¦        (define sÎ± (s Î±))
%% Â¦        (define Î±s* (if (set? sÎ±)
%% Â¦                        (for/fold ([Î±s* (set)])
%% Â¦                                  ([v (in-set sÎ±)])
%% Â¦                          (set-union Î±s* (roots-v v)))
%% Â¦                        (roots-v sÎ±)))
%% Â¦        (R (set-subtract (set-union Î±s* Î±s) seen)
%% Â¦           (set-add seen Î±))]))
%% Â¦   (R Î±s (set)))
%% Â¦ (define (roots e Ï)
%% Â¦   (for/set ([x (in-set (fv e))])
%% Â¦     (Ï x)))
%% Â¦ (define (roots-v v)
%% Â¦   (match v
%% Â¦     [(cons l Ï) (roots l Ï)]
%% Â¦     [_ (set)]))
%% \end{lstlisting}
%% \captionskip{Helper Functions for Garbage Collection}
%% \label{f:gc-help}
%% \end{figure} %}-}


%% \begin{figure} %{-{
%% \figskip\rfloat{â¸¨ev-cache-gc@â¸©}
%% \begin{lstlisting}
%% Â¦ (define (((ev-cache evâ‚€) ev) e)
%% Â¦   (do Ï   â† ask-env  Ïƒ â† get-store  Ïˆ â† ask-roots
%% Â¦       Ï‚   â‰” (list e Ï Ïƒ Ïˆ)
%% Â¦       Â¢â¸¢outâ¸£ â† get-cache-out
%% Â¦       (if (âˆˆ Ï‚ Â¢â¸¢outâ¸£)
%% Â¦           (for/monad+ ([vÃ—Ïƒ (Â¢â¸¢outâ¸£ Ï‚)])
%% Â¦             (do (put-store (cdr vÃ—Ïƒ))
%% Â¦                 (return (car vÃ—Ïƒ))))
%% Â¦           (do Â¢â¸¢inâ¸£    â† ask-cache-in
%% Â¦               vÃ—Ïƒâ‚€  â‰” (if (âˆˆ Ï‚ Â¢â¸¢inâ¸£) (Â¢â¸¢inâ¸£ Ï‚) âˆ…)
%% Â¦               (put-cache-out (Â¢â¸¢outâ¸£ Ï‚ vÃ—Ïƒâ‚€))
%% Â¦               v     â† ((evâ‚€ ev) e)
%% Â¦               Ïƒâ€²    â† get-store
%% Â¦               vÃ—Ïƒâ€²  â‰” (cons v Ïƒâ€²)
%% Â¦               (update-cache-out (Î» (Â¢â¸¢outâ¸£) (Â¢â¸¢outâ¸£ Ï‚ (set-add (Â¢â¸¢outâ¸£ Ï‚) vÃ—Ïƒâ€²))))
%% Â¦               (return v)))))
%% \end{lstlisting}
%% \figskip\rfloat{â¸¨fix-cache-gc@â¸©}
%% \begin{lstlisting}
%% Â¦ (define ((fix-cache eval) e)  
%% Â¦   (do Ï â† ask-env  Ïƒ â† get-store  Ïˆ â† ask-roots
%% Â¦       Ï‚ â‰” (list e Ï Ïƒ Ïˆ)
%% Â¦       Â¢âº â† (mlfp (Î» (Â¢) (do (put-cache-out âˆ…)
%% Â¦                             (put-store Ïƒ)
%% Â¦                             (local-cache-in Â¢ (eval e))
%% Â¦                             get-cache-out)))
%% Â¦       (for/monad+ ([vÃ—Ïƒ (Â¢âº Ï‚)])
%% Â¦         (do (put-store (cdr vÃ—Ïƒ))
%% Â¦             (return (car vÃ—Ïƒ))))))
%% \end{lstlisting}
%% \figskip\rfloat{â¸¨eval-cache-gc@â¸©}
%% \begin{lstlisting}
%% Â¦ (define (eval e)
%% Â¦   (mrun ((fix-cache (fix (ev-cache (ev-collect (ev-roots ev))))) e)))
%% \end{lstlisting}
%% \captionskip{Co-inductive Caching with Garbage Collection}
%% \label{f:gc-components}
%% \end{figure} %}-}

